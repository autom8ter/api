// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common/common.proto

#ifndef PROTOBUF_INCLUDED_common_2fcommon_2eproto
#define PROTOBUF_INCLUDED_common_2fcommon_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_common_2fcommon_2eproto 

namespace protobuf_common_2fcommon_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[10];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_common_2fcommon_2eproto
namespace common {
class AuthToken;
class AuthTokenDefaultTypeInternal;
extern AuthTokenDefaultTypeInternal _AuthToken_default_instance_;
class Bool;
class BoolDefaultTypeInternal;
extern BoolDefaultTypeInternal _Bool_default_instance_;
class Empty;
class EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class Float64;
class Float64DefaultTypeInternal;
extern Float64DefaultTypeInternal _Float64_default_instance_;
class Identifier;
class IdentifierDefaultTypeInternal;
extern IdentifierDefaultTypeInternal _Identifier_default_instance_;
class Int64;
class Int64DefaultTypeInternal;
extern Int64DefaultTypeInternal _Int64_default_instance_;
class String;
class StringDefaultTypeInternal;
extern StringDefaultTypeInternal _String_default_instance_;
class StringArray;
class StringArrayDefaultTypeInternal;
extern StringArrayDefaultTypeInternal _StringArray_default_instance_;
class StringMap;
class StringMapDefaultTypeInternal;
extern StringMapDefaultTypeInternal _StringMap_default_instance_;
class StringMap_StringMapEntry_DoNotUse;
class StringMap_StringMapEntry_DoNotUseDefaultTypeInternal;
extern StringMap_StringMapEntry_DoNotUseDefaultTypeInternal _StringMap_StringMapEntry_DoNotUse_default_instance_;
}  // namespace common
namespace google {
namespace protobuf {
template<> ::common::AuthToken* Arena::CreateMaybeMessage<::common::AuthToken>(Arena*);
template<> ::common::Bool* Arena::CreateMaybeMessage<::common::Bool>(Arena*);
template<> ::common::Empty* Arena::CreateMaybeMessage<::common::Empty>(Arena*);
template<> ::common::Float64* Arena::CreateMaybeMessage<::common::Float64>(Arena*);
template<> ::common::Identifier* Arena::CreateMaybeMessage<::common::Identifier>(Arena*);
template<> ::common::Int64* Arena::CreateMaybeMessage<::common::Int64>(Arena*);
template<> ::common::String* Arena::CreateMaybeMessage<::common::String>(Arena*);
template<> ::common::StringArray* Arena::CreateMaybeMessage<::common::StringArray>(Arena*);
template<> ::common::StringMap* Arena::CreateMaybeMessage<::common::StringMap>(Arena*);
template<> ::common::StringMap_StringMapEntry_DoNotUse* Arena::CreateMaybeMessage<::common::StringMap_StringMapEntry_DoNotUse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace common {

// ===================================================================

class String : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.String) */ {
 public:
  String();
  virtual ~String();

  String(const String& from);

  inline String& operator=(const String& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  String(String&& from) noexcept
    : String() {
    *this = ::std::move(from);
  }

  inline String& operator=(String&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const String& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const String* internal_default_instance() {
    return reinterpret_cast<const String*>(
               &_String_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(String* other);
  friend void swap(String& a, String& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline String* New() const final {
    return CreateMaybeMessage<String>(NULL);
  }

  String* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<String>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const String& from);
  void MergeFrom(const String& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(String* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string text = 1;
  void clear_text();
  static const int kTextFieldNumber = 1;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:common.String)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_common_2fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StringArray : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.StringArray) */ {
 public:
  StringArray();
  virtual ~StringArray();

  StringArray(const StringArray& from);

  inline StringArray& operator=(const StringArray& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StringArray(StringArray&& from) noexcept
    : StringArray() {
    *this = ::std::move(from);
  }

  inline StringArray& operator=(StringArray&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StringArray& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StringArray* internal_default_instance() {
    return reinterpret_cast<const StringArray*>(
               &_StringArray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(StringArray* other);
  friend void swap(StringArray& a, StringArray& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StringArray* New() const final {
    return CreateMaybeMessage<StringArray>(NULL);
  }

  StringArray* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StringArray>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StringArray& from);
  void MergeFrom(const StringArray& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StringArray* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .common.String strings = 1;
  int strings_size() const;
  void clear_strings();
  static const int kStringsFieldNumber = 1;
  ::common::String* mutable_strings(int index);
  ::google::protobuf::RepeatedPtrField< ::common::String >*
      mutable_strings();
  const ::common::String& strings(int index) const;
  ::common::String* add_strings();
  const ::google::protobuf::RepeatedPtrField< ::common::String >&
      strings() const;

  // @@protoc_insertion_point(class_scope:common.StringArray)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::common::String > strings_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_common_2fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StringMap_StringMapEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<StringMap_StringMapEntry_DoNotUse, 
    ::std::string, ::common::String,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<StringMap_StringMapEntry_DoNotUse, 
    ::std::string, ::common::String,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  StringMap_StringMapEntry_DoNotUse();
  StringMap_StringMapEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const StringMap_StringMapEntry_DoNotUse& other);
  static const StringMap_StringMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const StringMap_StringMapEntry_DoNotUse*>(&_StringMap_StringMapEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class StringMap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.StringMap) */ {
 public:
  StringMap();
  virtual ~StringMap();

  StringMap(const StringMap& from);

  inline StringMap& operator=(const StringMap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StringMap(StringMap&& from) noexcept
    : StringMap() {
    *this = ::std::move(from);
  }

  inline StringMap& operator=(StringMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StringMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StringMap* internal_default_instance() {
    return reinterpret_cast<const StringMap*>(
               &_StringMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(StringMap* other);
  friend void swap(StringMap& a, StringMap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StringMap* New() const final {
    return CreateMaybeMessage<StringMap>(NULL);
  }

  StringMap* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StringMap>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StringMap& from);
  void MergeFrom(const StringMap& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StringMap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .common.String> string_map = 1;
  int string_map_size() const;
  void clear_string_map();
  static const int kStringMapFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::common::String >&
      string_map() const;
  ::google::protobuf::Map< ::std::string, ::common::String >*
      mutable_string_map();

  // @@protoc_insertion_point(class_scope:common.StringMap)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      StringMap_StringMapEntry_DoNotUse,
      ::std::string, ::common::String,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > string_map_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_common_2fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Empty : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.Empty) */ {
 public:
  Empty();
  virtual ~Empty();

  Empty(const Empty& from);

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(Empty&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Empty& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Empty* other);
  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Empty* New() const final {
    return CreateMaybeMessage<Empty>(NULL);
  }

  Empty* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Empty& from);
  void MergeFrom(const Empty& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Empty* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:common.Empty)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_common_2fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Bool : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.Bool) */ {
 public:
  Bool();
  virtual ~Bool();

  Bool(const Bool& from);

  inline Bool& operator=(const Bool& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Bool(Bool&& from) noexcept
    : Bool() {
    *this = ::std::move(from);
  }

  inline Bool& operator=(Bool&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Bool& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Bool* internal_default_instance() {
    return reinterpret_cast<const Bool*>(
               &_Bool_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Bool* other);
  friend void swap(Bool& a, Bool& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Bool* New() const final {
    return CreateMaybeMessage<Bool>(NULL);
  }

  Bool* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Bool>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Bool& from);
  void MergeFrom(const Bool& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Bool* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool answer = 1;
  void clear_answer();
  static const int kAnswerFieldNumber = 1;
  bool answer() const;
  void set_answer(bool value);

  // @@protoc_insertion_point(class_scope:common.Bool)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool answer_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_common_2fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Identifier : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.Identifier) */ {
 public:
  Identifier();
  virtual ~Identifier();

  Identifier(const Identifier& from);

  inline Identifier& operator=(const Identifier& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Identifier(Identifier&& from) noexcept
    : Identifier() {
    *this = ::std::move(from);
  }

  inline Identifier& operator=(Identifier&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Identifier& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Identifier* internal_default_instance() {
    return reinterpret_cast<const Identifier*>(
               &_Identifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Identifier* other);
  friend void swap(Identifier& a, Identifier& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Identifier* New() const final {
    return CreateMaybeMessage<Identifier>(NULL);
  }

  Identifier* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Identifier>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Identifier& from);
  void MergeFrom(const Identifier& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Identifier* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .common.String id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  private:
  const ::common::String& _internal_id() const;
  public:
  const ::common::String& id() const;
  ::common::String* release_id();
  ::common::String* mutable_id();
  void set_allocated_id(::common::String* id);

  // @@protoc_insertion_point(class_scope:common.Identifier)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::common::String* id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_common_2fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AuthToken : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.AuthToken) */ {
 public:
  AuthToken();
  virtual ~AuthToken();

  AuthToken(const AuthToken& from);

  inline AuthToken& operator=(const AuthToken& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AuthToken(AuthToken&& from) noexcept
    : AuthToken() {
    *this = ::std::move(from);
  }

  inline AuthToken& operator=(AuthToken&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthToken& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AuthToken* internal_default_instance() {
    return reinterpret_cast<const AuthToken*>(
               &_AuthToken_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(AuthToken* other);
  friend void swap(AuthToken& a, AuthToken& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AuthToken* New() const final {
    return CreateMaybeMessage<AuthToken>(NULL);
  }

  AuthToken* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AuthToken>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AuthToken& from);
  void MergeFrom(const AuthToken& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthToken* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .common.String token = 1;
  bool has_token() const;
  void clear_token();
  static const int kTokenFieldNumber = 1;
  private:
  const ::common::String& _internal_token() const;
  public:
  const ::common::String& token() const;
  ::common::String* release_token();
  ::common::String* mutable_token();
  void set_allocated_token(::common::String* token);

  // @@protoc_insertion_point(class_scope:common.AuthToken)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::common::String* token_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_common_2fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Int64 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.Int64) */ {
 public:
  Int64();
  virtual ~Int64();

  Int64(const Int64& from);

  inline Int64& operator=(const Int64& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Int64(Int64&& from) noexcept
    : Int64() {
    *this = ::std::move(from);
  }

  inline Int64& operator=(Int64&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Int64& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Int64* internal_default_instance() {
    return reinterpret_cast<const Int64*>(
               &_Int64_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Int64* other);
  friend void swap(Int64& a, Int64& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Int64* New() const final {
    return CreateMaybeMessage<Int64>(NULL);
  }

  Int64* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Int64>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Int64& from);
  void MergeFrom(const Int64& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Int64* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 num = 1;
  void clear_num();
  static const int kNumFieldNumber = 1;
  ::google::protobuf::int64 num() const;
  void set_num(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:common.Int64)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 num_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_common_2fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Float64 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.Float64) */ {
 public:
  Float64();
  virtual ~Float64();

  Float64(const Float64& from);

  inline Float64& operator=(const Float64& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Float64(Float64&& from) noexcept
    : Float64() {
    *this = ::std::move(from);
  }

  inline Float64& operator=(Float64&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Float64& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Float64* internal_default_instance() {
    return reinterpret_cast<const Float64*>(
               &_Float64_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Float64* other);
  friend void swap(Float64& a, Float64& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Float64* New() const final {
    return CreateMaybeMessage<Float64>(NULL);
  }

  Float64* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Float64>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Float64& from);
  void MergeFrom(const Float64& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Float64* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double num = 1;
  void clear_num();
  static const int kNumFieldNumber = 1;
  double num() const;
  void set_num(double value);

  // @@protoc_insertion_point(class_scope:common.Float64)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double num_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_common_2fcommon_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// String

// string text = 1;
inline void String::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& String::text() const {
  // @@protoc_insertion_point(field_get:common.String.text)
  return text_.GetNoArena();
}
inline void String::set_text(const ::std::string& value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:common.String.text)
}
#if LANG_CXX11
inline void String::set_text(::std::string&& value) {
  
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:common.String.text)
}
#endif
inline void String::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:common.String.text)
}
inline void String::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:common.String.text)
}
inline ::std::string* String::mutable_text() {
  
  // @@protoc_insertion_point(field_mutable:common.String.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* String::release_text() {
  // @@protoc_insertion_point(field_release:common.String.text)
  
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void String::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:common.String.text)
}

// -------------------------------------------------------------------

// StringArray

// repeated .common.String strings = 1;
inline int StringArray::strings_size() const {
  return strings_.size();
}
inline void StringArray::clear_strings() {
  strings_.Clear();
}
inline ::common::String* StringArray::mutable_strings(int index) {
  // @@protoc_insertion_point(field_mutable:common.StringArray.strings)
  return strings_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::common::String >*
StringArray::mutable_strings() {
  // @@protoc_insertion_point(field_mutable_list:common.StringArray.strings)
  return &strings_;
}
inline const ::common::String& StringArray::strings(int index) const {
  // @@protoc_insertion_point(field_get:common.StringArray.strings)
  return strings_.Get(index);
}
inline ::common::String* StringArray::add_strings() {
  // @@protoc_insertion_point(field_add:common.StringArray.strings)
  return strings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::common::String >&
StringArray::strings() const {
  // @@protoc_insertion_point(field_list:common.StringArray.strings)
  return strings_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// StringMap

// map<string, .common.String> string_map = 1;
inline int StringMap::string_map_size() const {
  return string_map_.size();
}
inline void StringMap::clear_string_map() {
  string_map_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::common::String >&
StringMap::string_map() const {
  // @@protoc_insertion_point(field_map:common.StringMap.string_map)
  return string_map_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::common::String >*
StringMap::mutable_string_map() {
  // @@protoc_insertion_point(field_mutable_map:common.StringMap.string_map)
  return string_map_.MutableMap();
}

// -------------------------------------------------------------------

// Empty

// -------------------------------------------------------------------

// Bool

// bool answer = 1;
inline void Bool::clear_answer() {
  answer_ = false;
}
inline bool Bool::answer() const {
  // @@protoc_insertion_point(field_get:common.Bool.answer)
  return answer_;
}
inline void Bool::set_answer(bool value) {
  
  answer_ = value;
  // @@protoc_insertion_point(field_set:common.Bool.answer)
}

// -------------------------------------------------------------------

// Identifier

// .common.String id = 1;
inline bool Identifier::has_id() const {
  return this != internal_default_instance() && id_ != NULL;
}
inline void Identifier::clear_id() {
  if (GetArenaNoVirtual() == NULL && id_ != NULL) {
    delete id_;
  }
  id_ = NULL;
}
inline const ::common::String& Identifier::_internal_id() const {
  return *id_;
}
inline const ::common::String& Identifier::id() const {
  const ::common::String* p = id_;
  // @@protoc_insertion_point(field_get:common.Identifier.id)
  return p != NULL ? *p : *reinterpret_cast<const ::common::String*>(
      &::common::_String_default_instance_);
}
inline ::common::String* Identifier::release_id() {
  // @@protoc_insertion_point(field_release:common.Identifier.id)
  
  ::common::String* temp = id_;
  id_ = NULL;
  return temp;
}
inline ::common::String* Identifier::mutable_id() {
  
  if (id_ == NULL) {
    auto* p = CreateMaybeMessage<::common::String>(GetArenaNoVirtual());
    id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:common.Identifier.id)
  return id_;
}
inline void Identifier::set_allocated_id(::common::String* id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete id_;
  }
  if (id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:common.Identifier.id)
}

// -------------------------------------------------------------------

// AuthToken

// .common.String token = 1;
inline bool AuthToken::has_token() const {
  return this != internal_default_instance() && token_ != NULL;
}
inline void AuthToken::clear_token() {
  if (GetArenaNoVirtual() == NULL && token_ != NULL) {
    delete token_;
  }
  token_ = NULL;
}
inline const ::common::String& AuthToken::_internal_token() const {
  return *token_;
}
inline const ::common::String& AuthToken::token() const {
  const ::common::String* p = token_;
  // @@protoc_insertion_point(field_get:common.AuthToken.token)
  return p != NULL ? *p : *reinterpret_cast<const ::common::String*>(
      &::common::_String_default_instance_);
}
inline ::common::String* AuthToken::release_token() {
  // @@protoc_insertion_point(field_release:common.AuthToken.token)
  
  ::common::String* temp = token_;
  token_ = NULL;
  return temp;
}
inline ::common::String* AuthToken::mutable_token() {
  
  if (token_ == NULL) {
    auto* p = CreateMaybeMessage<::common::String>(GetArenaNoVirtual());
    token_ = p;
  }
  // @@protoc_insertion_point(field_mutable:common.AuthToken.token)
  return token_;
}
inline void AuthToken::set_allocated_token(::common::String* token) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete token_;
  }
  if (token) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      token = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, token, submessage_arena);
    }
    
  } else {
    
  }
  token_ = token;
  // @@protoc_insertion_point(field_set_allocated:common.AuthToken.token)
}

// -------------------------------------------------------------------

// Int64

// int64 num = 1;
inline void Int64::clear_num() {
  num_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Int64::num() const {
  // @@protoc_insertion_point(field_get:common.Int64.num)
  return num_;
}
inline void Int64::set_num(::google::protobuf::int64 value) {
  
  num_ = value;
  // @@protoc_insertion_point(field_set:common.Int64.num)
}

// -------------------------------------------------------------------

// Float64

// double num = 1;
inline void Float64::clear_num() {
  num_ = 0;
}
inline double Float64::num() const {
  // @@protoc_insertion_point(field_get:common.Float64.num)
  return num_;
}
inline void Float64::set_num(double value) {
  
  num_ = value;
  // @@protoc_insertion_point(field_set:common.Float64.num)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace common

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_common_2fcommon_2eproto
