// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common/common.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "common/Common.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - CommonRoot

@implementation CommonRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - CommonRoot_FileDescriptor

static GPBFileDescriptor *CommonRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"common"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - String

@implementation String

@dynamic text;

typedef struct String__storage_ {
  uint32_t _has_storage_[1];
  NSString *text;
} String__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "text",
        .dataTypeSpecific.className = NULL,
        .number = String_FieldNumber_Text,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(String__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[String class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(String__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - StringArray

@implementation StringArray

@dynamic stringsArray, stringsArray_Count;

typedef struct StringArray__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *stringsArray;
} StringArray__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "stringsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(String),
        .number = StringArray_FieldNumber_StringsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(StringArray__storage_, stringsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StringArray class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StringArray__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - StringMap

@implementation StringMap

@dynamic stringMap, stringMap_Count;

typedef struct StringMap__storage_ {
  uint32_t _has_storage_[1];
  NSMutableDictionary *stringMap;
} StringMap__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "stringMap",
        .dataTypeSpecific.className = GPBStringifySymbol(String),
        .number = StringMap_FieldNumber_StringMap,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(StringMap__storage_, stringMap),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StringMap class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StringMap__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Empty

@implementation Empty


typedef struct Empty__storage_ {
  uint32_t _has_storage_[1];
} Empty__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Empty class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(Empty__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Identifier

@implementation Identifier

@dynamic hasId_p, id_p;

typedef struct Identifier__storage_ {
  uint32_t _has_storage_[1];
  String *id_p;
} Identifier__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = GPBStringifySymbol(String),
        .number = Identifier_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Identifier__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Identifier class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Identifier__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Int64

@implementation Int64

@dynamic num;

typedef struct Int64__storage_ {
  uint32_t _has_storage_[1];
  int64_t num;
} Int64__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "num",
        .dataTypeSpecific.className = NULL,
        .number = Int64_FieldNumber_Num,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Int64__storage_, num),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Int64 class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Int64__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Float64

@implementation Float64

@dynamic num;

typedef struct Float64__storage_ {
  uint32_t _has_storage_[1];
  double num;
} Float64__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "num",
        .dataTypeSpecific.className = NULL,
        .number = Float64_FieldNumber_Num,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Float64__storage_, num),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Float64 class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Float64__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Token

@implementation Token

@dynamic hasAccessToken, accessToken;
@dynamic hasTokenType, tokenType;
@dynamic hasRefreshToken, refreshToken;
@dynamic hasExpiry, expiry;
@dynamic hasIdToken, idToken;

typedef struct Token__storage_ {
  uint32_t _has_storage_[1];
  String *accessToken;
  String *tokenType;
  String *refreshToken;
  String *expiry;
  String *idToken;
} Token__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accessToken",
        .dataTypeSpecific.className = GPBStringifySymbol(String),
        .number = Token_FieldNumber_AccessToken,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Token__storage_, accessToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tokenType",
        .dataTypeSpecific.className = GPBStringifySymbol(String),
        .number = Token_FieldNumber_TokenType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Token__storage_, tokenType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "refreshToken",
        .dataTypeSpecific.className = GPBStringifySymbol(String),
        .number = Token_FieldNumber_RefreshToken,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Token__storage_, refreshToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "expiry",
        .dataTypeSpecific.className = GPBStringifySymbol(String),
        .number = Token_FieldNumber_Expiry,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Token__storage_, expiry),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "idToken",
        .dataTypeSpecific.className = GPBStringifySymbol(String),
        .number = Token_FieldNumber_IdToken,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Token__storage_, idToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Token class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Token__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Config

@implementation Config

@dynamic hasClientId, clientId;
@dynamic hasClientSecret, clientSecret;
@dynamic hasTokenURL, tokenURL;
@dynamic hasScopes, scopes;
@dynamic hasEndpointParams, endpointParams;

typedef struct Config__storage_ {
  uint32_t _has_storage_[1];
  String *clientId;
  String *clientSecret;
  String *tokenURL;
  StringArray *scopes;
  StringMap *endpointParams;
} Config__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "clientId",
        .dataTypeSpecific.className = GPBStringifySymbol(String),
        .number = Config_FieldNumber_ClientId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Config__storage_, clientId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "clientSecret",
        .dataTypeSpecific.className = GPBStringifySymbol(String),
        .number = Config_FieldNumber_ClientSecret,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Config__storage_, clientSecret),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tokenURL",
        .dataTypeSpecific.className = GPBStringifySymbol(String),
        .number = Config_FieldNumber_TokenURL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Config__storage_, tokenURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "scopes",
        .dataTypeSpecific.className = GPBStringifySymbol(StringArray),
        .number = Config_FieldNumber_Scopes,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Config__storage_, scopes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "endpointParams",
        .dataTypeSpecific.className = GPBStringifySymbol(StringMap),
        .number = Config_FieldNumber_EndpointParams,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Config__storage_, endpointParams),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Config class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Config__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\005\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Event

@implementation Event

@dynamic hasAnnotations, annotations;

typedef struct Event__storage_ {
  uint32_t _has_storage_[1];
  StringMap *annotations;
} Event__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "annotations",
        .dataTypeSpecific.className = GPBStringifySymbol(StringMap),
        .number = Event_FieldNumber_Annotations,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Event__storage_, annotations),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Event class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Event__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Query

@implementation Query

@dynamic hasQuery, query;
@dynamic hasFields, fields;

typedef struct Query__storage_ {
  uint32_t _has_storage_[1];
  String *query;
  String *fields;
} Query__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = GPBStringifySymbol(String),
        .number = Query_FieldNumber_Query,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Query__storage_, query),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fields",
        .dataTypeSpecific.className = GPBStringifySymbol(String),
        .number = Query_FieldNumber_Fields,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Query__storage_, fields),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Query class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Query__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TokenSet

@implementation TokenSet

@dynamic tokens, tokens_Count;

typedef struct TokenSet__storage_ {
  uint32_t _has_storage_[1];
  NSMutableDictionary *tokens;
} TokenSet__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tokens",
        .dataTypeSpecific.className = GPBStringifySymbol(Token),
        .number = TokenSet_FieldNumber_Tokens,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TokenSet__storage_, tokens),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TokenSet class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TokenSet__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
