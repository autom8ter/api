// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common/common.proto

#ifndef PROTOBUF_INCLUDED_common_2fcommon_2eproto
#define PROTOBUF_INCLUDED_common_2fcommon_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_common_2fcommon_2eproto 

namespace protobuf_common_2fcommon_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[18];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_common_2fcommon_2eproto
namespace common {
class Bool;
class BoolDefaultTypeInternal;
extern BoolDefaultTypeInternal _Bool_default_instance_;
class Bytes;
class BytesDefaultTypeInternal;
extern BytesDefaultTypeInternal _Bytes_default_instance_;
class Empty;
class EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class Float64;
class Float64DefaultTypeInternal;
extern Float64DefaultTypeInternal _Float64_default_instance_;
class HTTPRequest;
class HTTPRequestDefaultTypeInternal;
extern HTTPRequestDefaultTypeInternal _HTTPRequest_default_instance_;
class Identifier;
class IdentifierDefaultTypeInternal;
extern IdentifierDefaultTypeInternal _Identifier_default_instance_;
class Int32;
class Int32DefaultTypeInternal;
extern Int32DefaultTypeInternal _Int32_default_instance_;
class Int64;
class Int64DefaultTypeInternal;
extern Int64DefaultTypeInternal _Int64_default_instance_;
class Message;
class MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class Password;
class PasswordDefaultTypeInternal;
extern PasswordDefaultTypeInternal _Password_default_instance_;
class Query;
class QueryDefaultTypeInternal;
extern QueryDefaultTypeInternal _Query_default_instance_;
class Secret;
class SecretDefaultTypeInternal;
extern SecretDefaultTypeInternal _Secret_default_instance_;
class String;
class StringDefaultTypeInternal;
extern StringDefaultTypeInternal _String_default_instance_;
class StringArray;
class StringArrayDefaultTypeInternal;
extern StringArrayDefaultTypeInternal _StringArray_default_instance_;
class StringMap;
class StringMapDefaultTypeInternal;
extern StringMapDefaultTypeInternal _StringMap_default_instance_;
class StringMap_StringMapEntry_DoNotUse;
class StringMap_StringMapEntry_DoNotUseDefaultTypeInternal;
extern StringMap_StringMapEntry_DoNotUseDefaultTypeInternal _StringMap_StringMapEntry_DoNotUse_default_instance_;
class Template;
class TemplateDefaultTypeInternal;
extern TemplateDefaultTypeInternal _Template_default_instance_;
class Token;
class TokenDefaultTypeInternal;
extern TokenDefaultTypeInternal _Token_default_instance_;
}  // namespace common
namespace google {
namespace protobuf {
template<> ::common::Bool* Arena::CreateMaybeMessage<::common::Bool>(Arena*);
template<> ::common::Bytes* Arena::CreateMaybeMessage<::common::Bytes>(Arena*);
template<> ::common::Empty* Arena::CreateMaybeMessage<::common::Empty>(Arena*);
template<> ::common::Float64* Arena::CreateMaybeMessage<::common::Float64>(Arena*);
template<> ::common::HTTPRequest* Arena::CreateMaybeMessage<::common::HTTPRequest>(Arena*);
template<> ::common::Identifier* Arena::CreateMaybeMessage<::common::Identifier>(Arena*);
template<> ::common::Int32* Arena::CreateMaybeMessage<::common::Int32>(Arena*);
template<> ::common::Int64* Arena::CreateMaybeMessage<::common::Int64>(Arena*);
template<> ::common::Message* Arena::CreateMaybeMessage<::common::Message>(Arena*);
template<> ::common::Password* Arena::CreateMaybeMessage<::common::Password>(Arena*);
template<> ::common::Query* Arena::CreateMaybeMessage<::common::Query>(Arena*);
template<> ::common::Secret* Arena::CreateMaybeMessage<::common::Secret>(Arena*);
template<> ::common::String* Arena::CreateMaybeMessage<::common::String>(Arena*);
template<> ::common::StringArray* Arena::CreateMaybeMessage<::common::StringArray>(Arena*);
template<> ::common::StringMap* Arena::CreateMaybeMessage<::common::StringMap>(Arena*);
template<> ::common::StringMap_StringMapEntry_DoNotUse* Arena::CreateMaybeMessage<::common::StringMap_StringMapEntry_DoNotUse>(Arena*);
template<> ::common::Template* Arena::CreateMaybeMessage<::common::Template>(Arena*);
template<> ::common::Token* Arena::CreateMaybeMessage<::common::Token>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace common {

enum HTTPMethod {
  GET = 0,
  POST = 1,
  PATCH = 2,
  HTTPMethod_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  HTTPMethod_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool HTTPMethod_IsValid(int value);
const HTTPMethod HTTPMethod_MIN = GET;
const HTTPMethod HTTPMethod_MAX = PATCH;
const int HTTPMethod_ARRAYSIZE = HTTPMethod_MAX + 1;

const ::google::protobuf::EnumDescriptor* HTTPMethod_descriptor();
inline const ::std::string& HTTPMethod_Name(HTTPMethod value) {
  return ::google::protobuf::internal::NameOfEnum(
    HTTPMethod_descriptor(), value);
}
inline bool HTTPMethod_Parse(
    const ::std::string& name, HTTPMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HTTPMethod>(
    HTTPMethod_descriptor(), name, value);
}
// ===================================================================

class String : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.String) */ {
 public:
  String();
  virtual ~String();

  String(const String& from);

  inline String& operator=(const String& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  String(String&& from) noexcept
    : String() {
    *this = ::std::move(from);
  }

  inline String& operator=(String&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const String& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const String* internal_default_instance() {
    return reinterpret_cast<const String*>(
               &_String_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(String* other);
  friend void swap(String& a, String& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline String* New() const final {
    return CreateMaybeMessage<String>(NULL);
  }

  String* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<String>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const String& from);
  void MergeFrom(const String& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(String* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string text = 1;
  void clear_text();
  static const int kTextFieldNumber = 1;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:common.String)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_common_2fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Bytes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.Bytes) */ {
 public:
  Bytes();
  virtual ~Bytes();

  Bytes(const Bytes& from);

  inline Bytes& operator=(const Bytes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Bytes(Bytes&& from) noexcept
    : Bytes() {
    *this = ::std::move(from);
  }

  inline Bytes& operator=(Bytes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Bytes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Bytes* internal_default_instance() {
    return reinterpret_cast<const Bytes*>(
               &_Bytes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Bytes* other);
  friend void swap(Bytes& a, Bytes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Bytes* New() const final {
    return CreateMaybeMessage<Bytes>(NULL);
  }

  Bytes* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Bytes>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Bytes& from);
  void MergeFrom(const Bytes& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Bytes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes bits = 1;
  void clear_bits();
  static const int kBitsFieldNumber = 1;
  const ::std::string& bits() const;
  void set_bits(const ::std::string& value);
  #if LANG_CXX11
  void set_bits(::std::string&& value);
  #endif
  void set_bits(const char* value);
  void set_bits(const void* value, size_t size);
  ::std::string* mutable_bits();
  ::std::string* release_bits();
  void set_allocated_bits(::std::string* bits);

  // @@protoc_insertion_point(class_scope:common.Bytes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_common_2fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Bool : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.Bool) */ {
 public:
  Bool();
  virtual ~Bool();

  Bool(const Bool& from);

  inline Bool& operator=(const Bool& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Bool(Bool&& from) noexcept
    : Bool() {
    *this = ::std::move(from);
  }

  inline Bool& operator=(Bool&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Bool& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Bool* internal_default_instance() {
    return reinterpret_cast<const Bool*>(
               &_Bool_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Bool* other);
  friend void swap(Bool& a, Bool& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Bool* New() const final {
    return CreateMaybeMessage<Bool>(NULL);
  }

  Bool* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Bool>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Bool& from);
  void MergeFrom(const Bool& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Bool* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool answer = 1;
  void clear_answer();
  static const int kAnswerFieldNumber = 1;
  bool answer() const;
  void set_answer(bool value);

  // @@protoc_insertion_point(class_scope:common.Bool)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool answer_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_common_2fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StringArray : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.StringArray) */ {
 public:
  StringArray();
  virtual ~StringArray();

  StringArray(const StringArray& from);

  inline StringArray& operator=(const StringArray& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StringArray(StringArray&& from) noexcept
    : StringArray() {
    *this = ::std::move(from);
  }

  inline StringArray& operator=(StringArray&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StringArray& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StringArray* internal_default_instance() {
    return reinterpret_cast<const StringArray*>(
               &_StringArray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(StringArray* other);
  friend void swap(StringArray& a, StringArray& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StringArray* New() const final {
    return CreateMaybeMessage<StringArray>(NULL);
  }

  StringArray* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StringArray>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StringArray& from);
  void MergeFrom(const StringArray& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StringArray* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string strings = 1;
  int strings_size() const;
  void clear_strings();
  static const int kStringsFieldNumber = 1;
  const ::std::string& strings(int index) const;
  ::std::string* mutable_strings(int index);
  void set_strings(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_strings(int index, ::std::string&& value);
  #endif
  void set_strings(int index, const char* value);
  void set_strings(int index, const char* value, size_t size);
  ::std::string* add_strings();
  void add_strings(const ::std::string& value);
  #if LANG_CXX11
  void add_strings(::std::string&& value);
  #endif
  void add_strings(const char* value);
  void add_strings(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& strings() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_strings();

  // @@protoc_insertion_point(class_scope:common.StringArray)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> strings_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_common_2fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StringMap_StringMapEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<StringMap_StringMapEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<StringMap_StringMapEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  StringMap_StringMapEntry_DoNotUse();
  StringMap_StringMapEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const StringMap_StringMapEntry_DoNotUse& other);
  static const StringMap_StringMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const StringMap_StringMapEntry_DoNotUse*>(&_StringMap_StringMapEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class StringMap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.StringMap) */ {
 public:
  StringMap();
  virtual ~StringMap();

  StringMap(const StringMap& from);

  inline StringMap& operator=(const StringMap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StringMap(StringMap&& from) noexcept
    : StringMap() {
    *this = ::std::move(from);
  }

  inline StringMap& operator=(StringMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StringMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StringMap* internal_default_instance() {
    return reinterpret_cast<const StringMap*>(
               &_StringMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(StringMap* other);
  friend void swap(StringMap& a, StringMap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StringMap* New() const final {
    return CreateMaybeMessage<StringMap>(NULL);
  }

  StringMap* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StringMap>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StringMap& from);
  void MergeFrom(const StringMap& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StringMap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> string_map = 1;
  int string_map_size() const;
  void clear_string_map();
  static const int kStringMapFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      string_map() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_string_map();

  // @@protoc_insertion_point(class_scope:common.StringMap)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      StringMap_StringMapEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > string_map_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_common_2fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Empty : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.Empty) */ {
 public:
  Empty();
  virtual ~Empty();

  Empty(const Empty& from);

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(Empty&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Empty& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Empty* other);
  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Empty* New() const final {
    return CreateMaybeMessage<Empty>(NULL);
  }

  Empty* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Empty& from);
  void MergeFrom(const Empty& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Empty* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:common.Empty)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_common_2fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Identifier : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.Identifier) */ {
 public:
  Identifier();
  virtual ~Identifier();

  Identifier(const Identifier& from);

  inline Identifier& operator=(const Identifier& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Identifier(Identifier&& from) noexcept
    : Identifier() {
    *this = ::std::move(from);
  }

  inline Identifier& operator=(Identifier&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Identifier& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Identifier* internal_default_instance() {
    return reinterpret_cast<const Identifier*>(
               &_Identifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Identifier* other);
  friend void swap(Identifier& a, Identifier& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Identifier* New() const final {
    return CreateMaybeMessage<Identifier>(NULL);
  }

  Identifier* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Identifier>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Identifier& from);
  void MergeFrom(const Identifier& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Identifier* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:common.Identifier)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_common_2fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.Message) */ {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(Message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Message* other);
  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Message* New() const final {
    return CreateMaybeMessage<Message>(NULL);
  }

  Message* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Message>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Message* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:common.Message)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_common_2fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Secret : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.Secret) */ {
 public:
  Secret();
  virtual ~Secret();

  Secret(const Secret& from);

  inline Secret& operator=(const Secret& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Secret(Secret&& from) noexcept
    : Secret() {
    *this = ::std::move(from);
  }

  inline Secret& operator=(Secret&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Secret& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Secret* internal_default_instance() {
    return reinterpret_cast<const Secret*>(
               &_Secret_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Secret* other);
  friend void swap(Secret& a, Secret& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Secret* New() const final {
    return CreateMaybeMessage<Secret>(NULL);
  }

  Secret* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Secret>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Secret& from);
  void MergeFrom(const Secret& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Secret* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string text = 1;
  void clear_text();
  static const int kTextFieldNumber = 1;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:common.Secret)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_common_2fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Query : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.Query) */ {
 public:
  Query();
  virtual ~Query();

  Query(const Query& from);

  inline Query& operator=(const Query& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Query(Query&& from) noexcept
    : Query() {
    *this = ::std::move(from);
  }

  inline Query& operator=(Query&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Query& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Query* internal_default_instance() {
    return reinterpret_cast<const Query*>(
               &_Query_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(Query* other);
  friend void swap(Query& a, Query& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Query* New() const final {
    return CreateMaybeMessage<Query>(NULL);
  }

  Query* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Query>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Query& from);
  void MergeFrom(const Query& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Query* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string lucene = 1;
  void clear_lucene();
  static const int kLuceneFieldNumber = 1;
  const ::std::string& lucene() const;
  void set_lucene(const ::std::string& value);
  #if LANG_CXX11
  void set_lucene(::std::string&& value);
  #endif
  void set_lucene(const char* value);
  void set_lucene(const char* value, size_t size);
  ::std::string* mutable_lucene();
  ::std::string* release_lucene();
  void set_allocated_lucene(::std::string* lucene);

  // @@protoc_insertion_point(class_scope:common.Query)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr lucene_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_common_2fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Password : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.Password) */ {
 public:
  Password();
  virtual ~Password();

  Password(const Password& from);

  inline Password& operator=(const Password& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Password(Password&& from) noexcept
    : Password() {
    *this = ::std::move(from);
  }

  inline Password& operator=(Password&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Password& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Password* internal_default_instance() {
    return reinterpret_cast<const Password*>(
               &_Password_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(Password* other);
  friend void swap(Password& a, Password& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Password* New() const final {
    return CreateMaybeMessage<Password>(NULL);
  }

  Password* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Password>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Password& from);
  void MergeFrom(const Password& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Password* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string text = 1;
  void clear_text();
  static const int kTextFieldNumber = 1;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:common.Password)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_common_2fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Int64 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.Int64) */ {
 public:
  Int64();
  virtual ~Int64();

  Int64(const Int64& from);

  inline Int64& operator=(const Int64& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Int64(Int64&& from) noexcept
    : Int64() {
    *this = ::std::move(from);
  }

  inline Int64& operator=(Int64&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Int64& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Int64* internal_default_instance() {
    return reinterpret_cast<const Int64*>(
               &_Int64_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(Int64* other);
  friend void swap(Int64& a, Int64& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Int64* New() const final {
    return CreateMaybeMessage<Int64>(NULL);
  }

  Int64* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Int64>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Int64& from);
  void MergeFrom(const Int64& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Int64* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 num = 1;
  void clear_num();
  static const int kNumFieldNumber = 1;
  ::google::protobuf::int64 num() const;
  void set_num(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:common.Int64)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 num_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_common_2fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Int32 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.Int32) */ {
 public:
  Int32();
  virtual ~Int32();

  Int32(const Int32& from);

  inline Int32& operator=(const Int32& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Int32(Int32&& from) noexcept
    : Int32() {
    *this = ::std::move(from);
  }

  inline Int32& operator=(Int32&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Int32& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Int32* internal_default_instance() {
    return reinterpret_cast<const Int32*>(
               &_Int32_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(Int32* other);
  friend void swap(Int32& a, Int32& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Int32* New() const final {
    return CreateMaybeMessage<Int32>(NULL);
  }

  Int32* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Int32>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Int32& from);
  void MergeFrom(const Int32& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Int32* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 num = 1;
  void clear_num();
  static const int kNumFieldNumber = 1;
  ::google::protobuf::int32 num() const;
  void set_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:common.Int32)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 num_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_common_2fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Float64 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.Float64) */ {
 public:
  Float64();
  virtual ~Float64();

  Float64(const Float64& from);

  inline Float64& operator=(const Float64& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Float64(Float64&& from) noexcept
    : Float64() {
    *this = ::std::move(from);
  }

  inline Float64& operator=(Float64&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Float64& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Float64* internal_default_instance() {
    return reinterpret_cast<const Float64*>(
               &_Float64_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(Float64* other);
  friend void swap(Float64& a, Float64& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Float64* New() const final {
    return CreateMaybeMessage<Float64>(NULL);
  }

  Float64* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Float64>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Float64& from);
  void MergeFrom(const Float64& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Float64* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double num = 1;
  void clear_num();
  static const int kNumFieldNumber = 1;
  double num() const;
  void set_num(double value);

  // @@protoc_insertion_point(class_scope:common.Float64)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double num_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_common_2fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HTTPRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.HTTPRequest) */ {
 public:
  HTTPRequest();
  virtual ~HTTPRequest();

  HTTPRequest(const HTTPRequest& from);

  inline HTTPRequest& operator=(const HTTPRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HTTPRequest(HTTPRequest&& from) noexcept
    : HTTPRequest() {
    *this = ::std::move(from);
  }

  inline HTTPRequest& operator=(HTTPRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HTTPRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HTTPRequest* internal_default_instance() {
    return reinterpret_cast<const HTTPRequest*>(
               &_HTTPRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(HTTPRequest* other);
  friend void swap(HTTPRequest& a, HTTPRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HTTPRequest* New() const final {
    return CreateMaybeMessage<HTTPRequest>(NULL);
  }

  HTTPRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HTTPRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HTTPRequest& from);
  void MergeFrom(const HTTPRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HTTPRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .common.String url = 2;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 2;
  private:
  const ::common::String& _internal_url() const;
  public:
  const ::common::String& url() const;
  ::common::String* release_url();
  ::common::String* mutable_url();
  void set_allocated_url(::common::String* url);

  // .common.StringMap form = 3;
  bool has_form() const;
  void clear_form();
  static const int kFormFieldNumber = 3;
  private:
  const ::common::StringMap& _internal_form() const;
  public:
  const ::common::StringMap& form() const;
  ::common::StringMap* release_form();
  ::common::StringMap* mutable_form();
  void set_allocated_form(::common::StringMap* form);

  // .common.Bytes body = 4;
  bool has_body() const;
  void clear_body();
  static const int kBodyFieldNumber = 4;
  private:
  const ::common::Bytes& _internal_body() const;
  public:
  const ::common::Bytes& body() const;
  ::common::Bytes* release_body();
  ::common::Bytes* mutable_body();
  void set_allocated_body(::common::Bytes* body);

  // .common.HTTPMethod method = 1;
  void clear_method();
  static const int kMethodFieldNumber = 1;
  ::common::HTTPMethod method() const;
  void set_method(::common::HTTPMethod value);

  // @@protoc_insertion_point(class_scope:common.HTTPRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::common::String* url_;
  ::common::StringMap* form_;
  ::common::Bytes* body_;
  int method_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_common_2fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Template : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.Template) */ {
 public:
  Template();
  virtual ~Template();

  Template(const Template& from);

  inline Template& operator=(const Template& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Template(Template&& from) noexcept
    : Template() {
    *this = ::std::move(from);
  }

  inline Template& operator=(Template&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Template& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Template* internal_default_instance() {
    return reinterpret_cast<const Template*>(
               &_Template_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(Template* other);
  friend void swap(Template& a, Template& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Template* New() const final {
    return CreateMaybeMessage<Template>(NULL);
  }

  Template* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Template>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Template& from);
  void MergeFrom(const Template& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Template* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .common.String name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  private:
  const ::common::String& _internal_name() const;
  public:
  const ::common::String& name() const;
  ::common::String* release_name();
  ::common::String* mutable_name();
  void set_allocated_name(::common::String* name);

  // .common.String text = 2;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 2;
  private:
  const ::common::String& _internal_text() const;
  public:
  const ::common::String& text() const;
  ::common::String* release_text();
  ::common::String* mutable_text();
  void set_allocated_text(::common::String* text);

  // @@protoc_insertion_point(class_scope:common.Template)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::common::String* name_;
  ::common::String* text_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_common_2fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Token : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.Token) */ {
 public:
  Token();
  virtual ~Token();

  Token(const Token& from);

  inline Token& operator=(const Token& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Token(Token&& from) noexcept
    : Token() {
    *this = ::std::move(from);
  }

  inline Token& operator=(Token&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Token& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Token* internal_default_instance() {
    return reinterpret_cast<const Token*>(
               &_Token_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(Token* other);
  friend void swap(Token& a, Token& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Token* New() const final {
    return CreateMaybeMessage<Token>(NULL);
  }

  Token* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Token>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Token& from);
  void MergeFrom(const Token& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Token* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .common.String access_token = 1;
  bool has_access_token() const;
  void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  private:
  const ::common::String& _internal_access_token() const;
  public:
  const ::common::String& access_token() const;
  ::common::String* release_access_token();
  ::common::String* mutable_access_token();
  void set_allocated_access_token(::common::String* access_token);

  // .common.String token_type = 2;
  bool has_token_type() const;
  void clear_token_type();
  static const int kTokenTypeFieldNumber = 2;
  private:
  const ::common::String& _internal_token_type() const;
  public:
  const ::common::String& token_type() const;
  ::common::String* release_token_type();
  ::common::String* mutable_token_type();
  void set_allocated_token_type(::common::String* token_type);

  // .common.String refresh_token = 3;
  bool has_refresh_token() const;
  void clear_refresh_token();
  static const int kRefreshTokenFieldNumber = 3;
  private:
  const ::common::String& _internal_refresh_token() const;
  public:
  const ::common::String& refresh_token() const;
  ::common::String* release_refresh_token();
  ::common::String* mutable_refresh_token();
  void set_allocated_refresh_token(::common::String* refresh_token);

  // .common.String expiry = 4;
  bool has_expiry() const;
  void clear_expiry();
  static const int kExpiryFieldNumber = 4;
  private:
  const ::common::String& _internal_expiry() const;
  public:
  const ::common::String& expiry() const;
  ::common::String* release_expiry();
  ::common::String* mutable_expiry();
  void set_allocated_expiry(::common::String* expiry);

  // .common.String id_token = 5;
  bool has_id_token() const;
  void clear_id_token();
  static const int kIdTokenFieldNumber = 5;
  private:
  const ::common::String& _internal_id_token() const;
  public:
  const ::common::String& id_token() const;
  ::common::String* release_id_token();
  ::common::String* mutable_id_token();
  void set_allocated_id_token(::common::String* id_token);

  // @@protoc_insertion_point(class_scope:common.Token)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::common::String* access_token_;
  ::common::String* token_type_;
  ::common::String* refresh_token_;
  ::common::String* expiry_;
  ::common::String* id_token_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_common_2fcommon_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// String

// string text = 1;
inline void String::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& String::text() const {
  // @@protoc_insertion_point(field_get:common.String.text)
  return text_.GetNoArena();
}
inline void String::set_text(const ::std::string& value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:common.String.text)
}
#if LANG_CXX11
inline void String::set_text(::std::string&& value) {
  
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:common.String.text)
}
#endif
inline void String::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:common.String.text)
}
inline void String::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:common.String.text)
}
inline ::std::string* String::mutable_text() {
  
  // @@protoc_insertion_point(field_mutable:common.String.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* String::release_text() {
  // @@protoc_insertion_point(field_release:common.String.text)
  
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void String::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:common.String.text)
}

// -------------------------------------------------------------------

// Bytes

// bytes bits = 1;
inline void Bytes::clear_bits() {
  bits_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Bytes::bits() const {
  // @@protoc_insertion_point(field_get:common.Bytes.bits)
  return bits_.GetNoArena();
}
inline void Bytes::set_bits(const ::std::string& value) {
  
  bits_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:common.Bytes.bits)
}
#if LANG_CXX11
inline void Bytes::set_bits(::std::string&& value) {
  
  bits_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:common.Bytes.bits)
}
#endif
inline void Bytes::set_bits(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  bits_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:common.Bytes.bits)
}
inline void Bytes::set_bits(const void* value, size_t size) {
  
  bits_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:common.Bytes.bits)
}
inline ::std::string* Bytes::mutable_bits() {
  
  // @@protoc_insertion_point(field_mutable:common.Bytes.bits)
  return bits_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Bytes::release_bits() {
  // @@protoc_insertion_point(field_release:common.Bytes.bits)
  
  return bits_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Bytes::set_allocated_bits(::std::string* bits) {
  if (bits != NULL) {
    
  } else {
    
  }
  bits_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bits);
  // @@protoc_insertion_point(field_set_allocated:common.Bytes.bits)
}

// -------------------------------------------------------------------

// Bool

// bool answer = 1;
inline void Bool::clear_answer() {
  answer_ = false;
}
inline bool Bool::answer() const {
  // @@protoc_insertion_point(field_get:common.Bool.answer)
  return answer_;
}
inline void Bool::set_answer(bool value) {
  
  answer_ = value;
  // @@protoc_insertion_point(field_set:common.Bool.answer)
}

// -------------------------------------------------------------------

// StringArray

// repeated string strings = 1;
inline int StringArray::strings_size() const {
  return strings_.size();
}
inline void StringArray::clear_strings() {
  strings_.Clear();
}
inline const ::std::string& StringArray::strings(int index) const {
  // @@protoc_insertion_point(field_get:common.StringArray.strings)
  return strings_.Get(index);
}
inline ::std::string* StringArray::mutable_strings(int index) {
  // @@protoc_insertion_point(field_mutable:common.StringArray.strings)
  return strings_.Mutable(index);
}
inline void StringArray::set_strings(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:common.StringArray.strings)
  strings_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void StringArray::set_strings(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:common.StringArray.strings)
  strings_.Mutable(index)->assign(std::move(value));
}
#endif
inline void StringArray::set_strings(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  strings_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:common.StringArray.strings)
}
inline void StringArray::set_strings(int index, const char* value, size_t size) {
  strings_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.StringArray.strings)
}
inline ::std::string* StringArray::add_strings() {
  // @@protoc_insertion_point(field_add_mutable:common.StringArray.strings)
  return strings_.Add();
}
inline void StringArray::add_strings(const ::std::string& value) {
  strings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:common.StringArray.strings)
}
#if LANG_CXX11
inline void StringArray::add_strings(::std::string&& value) {
  strings_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:common.StringArray.strings)
}
#endif
inline void StringArray::add_strings(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  strings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:common.StringArray.strings)
}
inline void StringArray::add_strings(const char* value, size_t size) {
  strings_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:common.StringArray.strings)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
StringArray::strings() const {
  // @@protoc_insertion_point(field_list:common.StringArray.strings)
  return strings_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
StringArray::mutable_strings() {
  // @@protoc_insertion_point(field_mutable_list:common.StringArray.strings)
  return &strings_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// StringMap

// map<string, string> string_map = 1;
inline int StringMap::string_map_size() const {
  return string_map_.size();
}
inline void StringMap::clear_string_map() {
  string_map_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
StringMap::string_map() const {
  // @@protoc_insertion_point(field_map:common.StringMap.string_map)
  return string_map_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
StringMap::mutable_string_map() {
  // @@protoc_insertion_point(field_mutable_map:common.StringMap.string_map)
  return string_map_.MutableMap();
}

// -------------------------------------------------------------------

// Empty

// -------------------------------------------------------------------

// Identifier

// string id = 1;
inline void Identifier::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Identifier::id() const {
  // @@protoc_insertion_point(field_get:common.Identifier.id)
  return id_.GetNoArena();
}
inline void Identifier::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:common.Identifier.id)
}
#if LANG_CXX11
inline void Identifier::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:common.Identifier.id)
}
#endif
inline void Identifier::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:common.Identifier.id)
}
inline void Identifier::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:common.Identifier.id)
}
inline ::std::string* Identifier::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:common.Identifier.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Identifier::release_id() {
  // @@protoc_insertion_point(field_release:common.Identifier.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Identifier::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:common.Identifier.id)
}

// -------------------------------------------------------------------

// Message

// string value = 1;
inline void Message::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Message::value() const {
  // @@protoc_insertion_point(field_get:common.Message.value)
  return value_.GetNoArena();
}
inline void Message::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:common.Message.value)
}
#if LANG_CXX11
inline void Message::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:common.Message.value)
}
#endif
inline void Message::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:common.Message.value)
}
inline void Message::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:common.Message.value)
}
inline ::std::string* Message::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:common.Message.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Message::release_value() {
  // @@protoc_insertion_point(field_release:common.Message.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:common.Message.value)
}

// -------------------------------------------------------------------

// Secret

// string text = 1;
inline void Secret::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Secret::text() const {
  // @@protoc_insertion_point(field_get:common.Secret.text)
  return text_.GetNoArena();
}
inline void Secret::set_text(const ::std::string& value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:common.Secret.text)
}
#if LANG_CXX11
inline void Secret::set_text(::std::string&& value) {
  
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:common.Secret.text)
}
#endif
inline void Secret::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:common.Secret.text)
}
inline void Secret::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:common.Secret.text)
}
inline ::std::string* Secret::mutable_text() {
  
  // @@protoc_insertion_point(field_mutable:common.Secret.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Secret::release_text() {
  // @@protoc_insertion_point(field_release:common.Secret.text)
  
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Secret::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:common.Secret.text)
}

// -------------------------------------------------------------------

// Query

// string lucene = 1;
inline void Query::clear_lucene() {
  lucene_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Query::lucene() const {
  // @@protoc_insertion_point(field_get:common.Query.lucene)
  return lucene_.GetNoArena();
}
inline void Query::set_lucene(const ::std::string& value) {
  
  lucene_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:common.Query.lucene)
}
#if LANG_CXX11
inline void Query::set_lucene(::std::string&& value) {
  
  lucene_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:common.Query.lucene)
}
#endif
inline void Query::set_lucene(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  lucene_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:common.Query.lucene)
}
inline void Query::set_lucene(const char* value, size_t size) {
  
  lucene_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:common.Query.lucene)
}
inline ::std::string* Query::mutable_lucene() {
  
  // @@protoc_insertion_point(field_mutable:common.Query.lucene)
  return lucene_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Query::release_lucene() {
  // @@protoc_insertion_point(field_release:common.Query.lucene)
  
  return lucene_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Query::set_allocated_lucene(::std::string* lucene) {
  if (lucene != NULL) {
    
  } else {
    
  }
  lucene_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lucene);
  // @@protoc_insertion_point(field_set_allocated:common.Query.lucene)
}

// -------------------------------------------------------------------

// Password

// string text = 1;
inline void Password::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Password::text() const {
  // @@protoc_insertion_point(field_get:common.Password.text)
  return text_.GetNoArena();
}
inline void Password::set_text(const ::std::string& value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:common.Password.text)
}
#if LANG_CXX11
inline void Password::set_text(::std::string&& value) {
  
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:common.Password.text)
}
#endif
inline void Password::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:common.Password.text)
}
inline void Password::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:common.Password.text)
}
inline ::std::string* Password::mutable_text() {
  
  // @@protoc_insertion_point(field_mutable:common.Password.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Password::release_text() {
  // @@protoc_insertion_point(field_release:common.Password.text)
  
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Password::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:common.Password.text)
}

// -------------------------------------------------------------------

// Int64

// int64 num = 1;
inline void Int64::clear_num() {
  num_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Int64::num() const {
  // @@protoc_insertion_point(field_get:common.Int64.num)
  return num_;
}
inline void Int64::set_num(::google::protobuf::int64 value) {
  
  num_ = value;
  // @@protoc_insertion_point(field_set:common.Int64.num)
}

// -------------------------------------------------------------------

// Int32

// int32 num = 1;
inline void Int32::clear_num() {
  num_ = 0;
}
inline ::google::protobuf::int32 Int32::num() const {
  // @@protoc_insertion_point(field_get:common.Int32.num)
  return num_;
}
inline void Int32::set_num(::google::protobuf::int32 value) {
  
  num_ = value;
  // @@protoc_insertion_point(field_set:common.Int32.num)
}

// -------------------------------------------------------------------

// Float64

// double num = 1;
inline void Float64::clear_num() {
  num_ = 0;
}
inline double Float64::num() const {
  // @@protoc_insertion_point(field_get:common.Float64.num)
  return num_;
}
inline void Float64::set_num(double value) {
  
  num_ = value;
  // @@protoc_insertion_point(field_set:common.Float64.num)
}

// -------------------------------------------------------------------

// HTTPRequest

// .common.HTTPMethod method = 1;
inline void HTTPRequest::clear_method() {
  method_ = 0;
}
inline ::common::HTTPMethod HTTPRequest::method() const {
  // @@protoc_insertion_point(field_get:common.HTTPRequest.method)
  return static_cast< ::common::HTTPMethod >(method_);
}
inline void HTTPRequest::set_method(::common::HTTPMethod value) {
  
  method_ = value;
  // @@protoc_insertion_point(field_set:common.HTTPRequest.method)
}

// .common.String url = 2;
inline bool HTTPRequest::has_url() const {
  return this != internal_default_instance() && url_ != NULL;
}
inline void HTTPRequest::clear_url() {
  if (GetArenaNoVirtual() == NULL && url_ != NULL) {
    delete url_;
  }
  url_ = NULL;
}
inline const ::common::String& HTTPRequest::_internal_url() const {
  return *url_;
}
inline const ::common::String& HTTPRequest::url() const {
  const ::common::String* p = url_;
  // @@protoc_insertion_point(field_get:common.HTTPRequest.url)
  return p != NULL ? *p : *reinterpret_cast<const ::common::String*>(
      &::common::_String_default_instance_);
}
inline ::common::String* HTTPRequest::release_url() {
  // @@protoc_insertion_point(field_release:common.HTTPRequest.url)
  
  ::common::String* temp = url_;
  url_ = NULL;
  return temp;
}
inline ::common::String* HTTPRequest::mutable_url() {
  
  if (url_ == NULL) {
    auto* p = CreateMaybeMessage<::common::String>(GetArenaNoVirtual());
    url_ = p;
  }
  // @@protoc_insertion_point(field_mutable:common.HTTPRequest.url)
  return url_;
}
inline void HTTPRequest::set_allocated_url(::common::String* url) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete url_;
  }
  if (url) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      url = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, url, submessage_arena);
    }
    
  } else {
    
  }
  url_ = url;
  // @@protoc_insertion_point(field_set_allocated:common.HTTPRequest.url)
}

// .common.StringMap form = 3;
inline bool HTTPRequest::has_form() const {
  return this != internal_default_instance() && form_ != NULL;
}
inline void HTTPRequest::clear_form() {
  if (GetArenaNoVirtual() == NULL && form_ != NULL) {
    delete form_;
  }
  form_ = NULL;
}
inline const ::common::StringMap& HTTPRequest::_internal_form() const {
  return *form_;
}
inline const ::common::StringMap& HTTPRequest::form() const {
  const ::common::StringMap* p = form_;
  // @@protoc_insertion_point(field_get:common.HTTPRequest.form)
  return p != NULL ? *p : *reinterpret_cast<const ::common::StringMap*>(
      &::common::_StringMap_default_instance_);
}
inline ::common::StringMap* HTTPRequest::release_form() {
  // @@protoc_insertion_point(field_release:common.HTTPRequest.form)
  
  ::common::StringMap* temp = form_;
  form_ = NULL;
  return temp;
}
inline ::common::StringMap* HTTPRequest::mutable_form() {
  
  if (form_ == NULL) {
    auto* p = CreateMaybeMessage<::common::StringMap>(GetArenaNoVirtual());
    form_ = p;
  }
  // @@protoc_insertion_point(field_mutable:common.HTTPRequest.form)
  return form_;
}
inline void HTTPRequest::set_allocated_form(::common::StringMap* form) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete form_;
  }
  if (form) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      form = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, form, submessage_arena);
    }
    
  } else {
    
  }
  form_ = form;
  // @@protoc_insertion_point(field_set_allocated:common.HTTPRequest.form)
}

// .common.Bytes body = 4;
inline bool HTTPRequest::has_body() const {
  return this != internal_default_instance() && body_ != NULL;
}
inline void HTTPRequest::clear_body() {
  if (GetArenaNoVirtual() == NULL && body_ != NULL) {
    delete body_;
  }
  body_ = NULL;
}
inline const ::common::Bytes& HTTPRequest::_internal_body() const {
  return *body_;
}
inline const ::common::Bytes& HTTPRequest::body() const {
  const ::common::Bytes* p = body_;
  // @@protoc_insertion_point(field_get:common.HTTPRequest.body)
  return p != NULL ? *p : *reinterpret_cast<const ::common::Bytes*>(
      &::common::_Bytes_default_instance_);
}
inline ::common::Bytes* HTTPRequest::release_body() {
  // @@protoc_insertion_point(field_release:common.HTTPRequest.body)
  
  ::common::Bytes* temp = body_;
  body_ = NULL;
  return temp;
}
inline ::common::Bytes* HTTPRequest::mutable_body() {
  
  if (body_ == NULL) {
    auto* p = CreateMaybeMessage<::common::Bytes>(GetArenaNoVirtual());
    body_ = p;
  }
  // @@protoc_insertion_point(field_mutable:common.HTTPRequest.body)
  return body_;
}
inline void HTTPRequest::set_allocated_body(::common::Bytes* body) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete body_;
  }
  if (body) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      body = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, body, submessage_arena);
    }
    
  } else {
    
  }
  body_ = body;
  // @@protoc_insertion_point(field_set_allocated:common.HTTPRequest.body)
}

// -------------------------------------------------------------------

// Template

// .common.String name = 1;
inline bool Template::has_name() const {
  return this != internal_default_instance() && name_ != NULL;
}
inline void Template::clear_name() {
  if (GetArenaNoVirtual() == NULL && name_ != NULL) {
    delete name_;
  }
  name_ = NULL;
}
inline const ::common::String& Template::_internal_name() const {
  return *name_;
}
inline const ::common::String& Template::name() const {
  const ::common::String* p = name_;
  // @@protoc_insertion_point(field_get:common.Template.name)
  return p != NULL ? *p : *reinterpret_cast<const ::common::String*>(
      &::common::_String_default_instance_);
}
inline ::common::String* Template::release_name() {
  // @@protoc_insertion_point(field_release:common.Template.name)
  
  ::common::String* temp = name_;
  name_ = NULL;
  return temp;
}
inline ::common::String* Template::mutable_name() {
  
  if (name_ == NULL) {
    auto* p = CreateMaybeMessage<::common::String>(GetArenaNoVirtual());
    name_ = p;
  }
  // @@protoc_insertion_point(field_mutable:common.Template.name)
  return name_;
}
inline void Template::set_allocated_name(::common::String* name) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete name_;
  }
  if (name) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      name = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, name, submessage_arena);
    }
    
  } else {
    
  }
  name_ = name;
  // @@protoc_insertion_point(field_set_allocated:common.Template.name)
}

// .common.String text = 2;
inline bool Template::has_text() const {
  return this != internal_default_instance() && text_ != NULL;
}
inline void Template::clear_text() {
  if (GetArenaNoVirtual() == NULL && text_ != NULL) {
    delete text_;
  }
  text_ = NULL;
}
inline const ::common::String& Template::_internal_text() const {
  return *text_;
}
inline const ::common::String& Template::text() const {
  const ::common::String* p = text_;
  // @@protoc_insertion_point(field_get:common.Template.text)
  return p != NULL ? *p : *reinterpret_cast<const ::common::String*>(
      &::common::_String_default_instance_);
}
inline ::common::String* Template::release_text() {
  // @@protoc_insertion_point(field_release:common.Template.text)
  
  ::common::String* temp = text_;
  text_ = NULL;
  return temp;
}
inline ::common::String* Template::mutable_text() {
  
  if (text_ == NULL) {
    auto* p = CreateMaybeMessage<::common::String>(GetArenaNoVirtual());
    text_ = p;
  }
  // @@protoc_insertion_point(field_mutable:common.Template.text)
  return text_;
}
inline void Template::set_allocated_text(::common::String* text) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete text_;
  }
  if (text) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      text = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, text, submessage_arena);
    }
    
  } else {
    
  }
  text_ = text;
  // @@protoc_insertion_point(field_set_allocated:common.Template.text)
}

// -------------------------------------------------------------------

// Token

// .common.String access_token = 1;
inline bool Token::has_access_token() const {
  return this != internal_default_instance() && access_token_ != NULL;
}
inline void Token::clear_access_token() {
  if (GetArenaNoVirtual() == NULL && access_token_ != NULL) {
    delete access_token_;
  }
  access_token_ = NULL;
}
inline const ::common::String& Token::_internal_access_token() const {
  return *access_token_;
}
inline const ::common::String& Token::access_token() const {
  const ::common::String* p = access_token_;
  // @@protoc_insertion_point(field_get:common.Token.access_token)
  return p != NULL ? *p : *reinterpret_cast<const ::common::String*>(
      &::common::_String_default_instance_);
}
inline ::common::String* Token::release_access_token() {
  // @@protoc_insertion_point(field_release:common.Token.access_token)
  
  ::common::String* temp = access_token_;
  access_token_ = NULL;
  return temp;
}
inline ::common::String* Token::mutable_access_token() {
  
  if (access_token_ == NULL) {
    auto* p = CreateMaybeMessage<::common::String>(GetArenaNoVirtual());
    access_token_ = p;
  }
  // @@protoc_insertion_point(field_mutable:common.Token.access_token)
  return access_token_;
}
inline void Token::set_allocated_access_token(::common::String* access_token) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete access_token_;
  }
  if (access_token) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      access_token = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, access_token, submessage_arena);
    }
    
  } else {
    
  }
  access_token_ = access_token;
  // @@protoc_insertion_point(field_set_allocated:common.Token.access_token)
}

// .common.String token_type = 2;
inline bool Token::has_token_type() const {
  return this != internal_default_instance() && token_type_ != NULL;
}
inline void Token::clear_token_type() {
  if (GetArenaNoVirtual() == NULL && token_type_ != NULL) {
    delete token_type_;
  }
  token_type_ = NULL;
}
inline const ::common::String& Token::_internal_token_type() const {
  return *token_type_;
}
inline const ::common::String& Token::token_type() const {
  const ::common::String* p = token_type_;
  // @@protoc_insertion_point(field_get:common.Token.token_type)
  return p != NULL ? *p : *reinterpret_cast<const ::common::String*>(
      &::common::_String_default_instance_);
}
inline ::common::String* Token::release_token_type() {
  // @@protoc_insertion_point(field_release:common.Token.token_type)
  
  ::common::String* temp = token_type_;
  token_type_ = NULL;
  return temp;
}
inline ::common::String* Token::mutable_token_type() {
  
  if (token_type_ == NULL) {
    auto* p = CreateMaybeMessage<::common::String>(GetArenaNoVirtual());
    token_type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:common.Token.token_type)
  return token_type_;
}
inline void Token::set_allocated_token_type(::common::String* token_type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete token_type_;
  }
  if (token_type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      token_type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, token_type, submessage_arena);
    }
    
  } else {
    
  }
  token_type_ = token_type;
  // @@protoc_insertion_point(field_set_allocated:common.Token.token_type)
}

// .common.String refresh_token = 3;
inline bool Token::has_refresh_token() const {
  return this != internal_default_instance() && refresh_token_ != NULL;
}
inline void Token::clear_refresh_token() {
  if (GetArenaNoVirtual() == NULL && refresh_token_ != NULL) {
    delete refresh_token_;
  }
  refresh_token_ = NULL;
}
inline const ::common::String& Token::_internal_refresh_token() const {
  return *refresh_token_;
}
inline const ::common::String& Token::refresh_token() const {
  const ::common::String* p = refresh_token_;
  // @@protoc_insertion_point(field_get:common.Token.refresh_token)
  return p != NULL ? *p : *reinterpret_cast<const ::common::String*>(
      &::common::_String_default_instance_);
}
inline ::common::String* Token::release_refresh_token() {
  // @@protoc_insertion_point(field_release:common.Token.refresh_token)
  
  ::common::String* temp = refresh_token_;
  refresh_token_ = NULL;
  return temp;
}
inline ::common::String* Token::mutable_refresh_token() {
  
  if (refresh_token_ == NULL) {
    auto* p = CreateMaybeMessage<::common::String>(GetArenaNoVirtual());
    refresh_token_ = p;
  }
  // @@protoc_insertion_point(field_mutable:common.Token.refresh_token)
  return refresh_token_;
}
inline void Token::set_allocated_refresh_token(::common::String* refresh_token) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete refresh_token_;
  }
  if (refresh_token) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      refresh_token = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, refresh_token, submessage_arena);
    }
    
  } else {
    
  }
  refresh_token_ = refresh_token;
  // @@protoc_insertion_point(field_set_allocated:common.Token.refresh_token)
}

// .common.String expiry = 4;
inline bool Token::has_expiry() const {
  return this != internal_default_instance() && expiry_ != NULL;
}
inline void Token::clear_expiry() {
  if (GetArenaNoVirtual() == NULL && expiry_ != NULL) {
    delete expiry_;
  }
  expiry_ = NULL;
}
inline const ::common::String& Token::_internal_expiry() const {
  return *expiry_;
}
inline const ::common::String& Token::expiry() const {
  const ::common::String* p = expiry_;
  // @@protoc_insertion_point(field_get:common.Token.expiry)
  return p != NULL ? *p : *reinterpret_cast<const ::common::String*>(
      &::common::_String_default_instance_);
}
inline ::common::String* Token::release_expiry() {
  // @@protoc_insertion_point(field_release:common.Token.expiry)
  
  ::common::String* temp = expiry_;
  expiry_ = NULL;
  return temp;
}
inline ::common::String* Token::mutable_expiry() {
  
  if (expiry_ == NULL) {
    auto* p = CreateMaybeMessage<::common::String>(GetArenaNoVirtual());
    expiry_ = p;
  }
  // @@protoc_insertion_point(field_mutable:common.Token.expiry)
  return expiry_;
}
inline void Token::set_allocated_expiry(::common::String* expiry) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete expiry_;
  }
  if (expiry) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      expiry = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, expiry, submessage_arena);
    }
    
  } else {
    
  }
  expiry_ = expiry;
  // @@protoc_insertion_point(field_set_allocated:common.Token.expiry)
}

// .common.String id_token = 5;
inline bool Token::has_id_token() const {
  return this != internal_default_instance() && id_token_ != NULL;
}
inline void Token::clear_id_token() {
  if (GetArenaNoVirtual() == NULL && id_token_ != NULL) {
    delete id_token_;
  }
  id_token_ = NULL;
}
inline const ::common::String& Token::_internal_id_token() const {
  return *id_token_;
}
inline const ::common::String& Token::id_token() const {
  const ::common::String* p = id_token_;
  // @@protoc_insertion_point(field_get:common.Token.id_token)
  return p != NULL ? *p : *reinterpret_cast<const ::common::String*>(
      &::common::_String_default_instance_);
}
inline ::common::String* Token::release_id_token() {
  // @@protoc_insertion_point(field_release:common.Token.id_token)
  
  ::common::String* temp = id_token_;
  id_token_ = NULL;
  return temp;
}
inline ::common::String* Token::mutable_id_token() {
  
  if (id_token_ == NULL) {
    auto* p = CreateMaybeMessage<::common::String>(GetArenaNoVirtual());
    id_token_ = p;
  }
  // @@protoc_insertion_point(field_mutable:common.Token.id_token)
  return id_token_;
}
inline void Token::set_allocated_id_token(::common::String* id_token) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete id_token_;
  }
  if (id_token) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      id_token = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, id_token, submessage_arena);
    }
    
  } else {
    
  }
  id_token_ = id_token;
  // @@protoc_insertion_point(field_set_allocated:common.Token.id_token)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace common

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::common::HTTPMethod> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::HTTPMethod>() {
  return ::common::HTTPMethod_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_common_2fcommon_2eproto
