// Code generated by protoc-gen-go. DO NOT EDIT.
// source: api/api.proto

package api

import (
	context "context"
	fmt "fmt"
	auth "github.com/autom8ter/api/sdk/go/auth"
	blob "github.com/autom8ter/api/sdk/go/blob"
	documents "github.com/autom8ter/api/sdk/go/documents"
	errors "github.com/autom8ter/api/sdk/go/errors"
	images "github.com/autom8ter/api/sdk/go/images"
	os "github.com/autom8ter/api/sdk/go/os"
	sms "github.com/autom8ter/api/sdk/go/sms"
	streaming "github.com/autom8ter/api/sdk/go/streaming"
	strings "github.com/autom8ter/api/sdk/go/strings"
	voice "github.com/autom8ter/api/sdk/go/voice"
	proto "github.com/golang/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

func init() { proto.RegisterFile("api/api.proto", fileDescriptor_1b40cafcd4234784) }

var fileDescriptor_1b40cafcd4234784 = []byte{
	// 1111 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x57, 0xcb, 0x6e, 0xdb, 0x46,
	0x14, 0x95, 0x9c, 0xda, 0x8e, 0xaf, 0x24, 0xc7, 0x1e, 0xc7, 0x2f, 0x35, 0x68, 0x0b, 0x75, 0xe3,
	0x45, 0x4b, 0x1a, 0x2a, 0x52, 0x20, 0x4d, 0xe1, 0xc0, 0x91, 0x03, 0xd7, 0x40, 0x8d, 0xb4, 0x62,
	0x1e, 0xab, 0x2c, 0x68, 0xea, 0x46, 0x66, 0x4d, 0x71, 0x58, 0xce, 0xd8, 0x88, 0xff, 0xa1, 0x8b,
	0x02, 0xfd, 0xa5, 0x76, 0xd1, 0x4d, 0xff, 0xa2, 0x1f, 0x50, 0xa0, 0x1f, 0x50, 0x70, 0xde, 0x7c,
	0x48, 0xee, 0xc6, 0x24, 0xcf, 0xb9, 0xe7, 0xf0, 0xce, 0xe1, 0x68, 0x66, 0x0c, 0xbd, 0x30, 0x8b,
	0xfd, 0x30, 0x8b, 0xbd, 0x2c, 0xa7, 0x9c, 0x92, 0x7b, 0x61, 0x16, 0xf7, 0x1f, 0x4d, 0x29, 0x9d,
	0x26, 0xe8, 0x0b, 0x2a, 0x4d, 0x29, 0x0f, 0x79, 0x4c, 0x53, 0x26, 0x4b, 0xfa, 0x0f, 0xc2, 0x6b,
	0x7e, 0xe9, 0x17, 0x7f, 0x14, 0x40, 0x2e, 0x12, 0x7a, 0xe1, 0x33, 0x4e, 0xf3, 0x70, 0x8a, 0x0a,
	0xdb, 0x8a, 0x67, 0xe1, 0x14, 0x99, 0x2f, 0x2f, 0x0a, 0xec, 0xb1, 0x19, 0xf3, 0xd9, 0x4c, 0x3f,
	0x6e, 0xde, 0xd0, 0x38, 0x42, 0x5f, 0xfc, 0x55, 0xd0, 0xfe, 0x84, 0x46, 0xd7, 0x33, 0x4c, 0x39,
	0xf3, 0xcd, 0x9d, 0xa2, 0xb6, 0x19, 0xcf, 0xe3, 0x74, 0xca, 0x7c, 0x75, 0xd5, 0x0a, 0xc6, 0x73,
	0x0c, 0x67, 0x71, 0x3a, 0xf5, 0xcd, 0x9d, 0xee, 0x01, 0xf3, 0x9c, 0xe6, 0xcc, 0x97, 0x17, 0x05,
	0x76, 0x28, 0xf3, 0xa9, 0x7a, 0x18, 0x1e, 0x01, 0x19, 0x61, 0xce, 0xe3, 0xf7, 0x71, 0x14, 0x72,
	0x0c, 0x30, 0xbf, 0x89, 0x23, 0x24, 0x07, 0x70, 0x7f, 0x8c, 0xd3, 0x98, 0x71, 0xcc, 0xc9, 0x9a,
	0x27, 0x06, 0x3a, 0x0a, 0xc6, 0xfd, 0x4d, 0x75, 0x6b, 0x05, 0xc3, 0xdf, 0x97, 0xa0, 0xf3, 0x9a,
	0x61, 0xae, 0x95, 0x5f, 0x00, 0x8c, 0x72, 0x0c, 0x39, 0x16, 0x20, 0x01, 0x29, 0x28, 0xee, 0xfb,
	0x1b, 0xf6, 0x7e, 0x8c, 0x11, 0xcd, 0x27, 0x83, 0x16, 0x39, 0x80, 0x95, 0xd7, 0xd9, 0x24, 0xe4,
	0x78, 0x67, 0xe5, 0xd7, 0x00, 0x27, 0x98, 0xa0, 0xf2, 0xdd, 0x95, 0x15, 0x16, 0x19, 0xe3, 0xcf,
	0xd7, 0xc8, 0x78, 0xbf, 0xe7, 0xa9, 0xa1, 0xbe, 0x28, 0x2e, 0x83, 0x16, 0x39, 0x84, 0xd5, 0x53,
	0xe4, 0x42, 0xa4, 0xba, 0x57, 0x8f, 0xcf, 0x6f, 0xcf, 0x4e, 0x1a, 0xdf, 0xf4, 0x18, 0xee, 0xab,
	0x12, 0x46, 0x88, 0xe5, 0x99, 0x7e, 0xc5, 0x96, 0x83, 0x9d, 0x71, 0xcc, 0x43, 0x2e, 0x5e, 0xf4,
	0x2d, 0xf4, 0x02, 0x29, 0x1b, 0x25, 0x61, 0x3c, 0x63, 0xa4, 0x2f, 0xeb, 0x4a, 0xe0, 0xbc, 0x36,
	0x87, 0x7f, 0xb6, 0xa1, 0xfb, 0x8a, 0x5e, 0x61, 0xaa, 0x73, 0x3c, 0x81, 0xce, 0xe8, 0x9a, 0x71,
	0x3a, 0x13, 0x28, 0xd9, 0x53, 0xc9, 0x5b, 0x48, 0x5b, 0xed, 0x37, 0x30, 0x2c, 0xa3, 0x29, 0xc3,
	0x41, 0x8b, 0x3c, 0x85, 0xce, 0x18, 0x6f, 0xe8, 0x15, 0x96, 0x5c, 0x1c, 0x48, 0xbb, 0x34, 0x47,
	0xde, 0x79, 0x83, 0x79, 0xfc, 0xfe, 0xb6, 0x24, 0x76, 0x20, 0x2d, 0xee, 0x48, 0x46, 0x60, 0x83,
	0xd6, 0xf0, 0xaf, 0x25, 0xe8, 0xbd, 0xbc, 0xf8, 0x09, 0x23, 0xae, 0x07, 0x73, 0x0c, 0x5d, 0x39,
	0x29, 0x24, 0x4c, 0xf6, 0xbd, 0xe2, 0xf7, 0xe2, 0xb9, 0x98, 0xf6, 0x7a, 0x28, 0x29, 0x0d, 0x3a,
	0x23, 0x59, 0x3b, 0x45, 0xae, 0xf4, 0x3b, 0xb2, 0xc8, 0x00, 0x77, 0x89, 0x8f, 0x00, 0x4c, 0x2d,
	0x23, 0xbb, 0x15, 0xb5, 0xf9, 0x2a, 0xdb, 0xae, 0x9c, 0x39, 0xfa, 0x63, 0xe8, 0xca, 0x69, 0x5a,
	0xee, 0xdf, 0xc5, 0xee, 0x6a, 0xe1, 0x1b, 0xe8, 0xca, 0xd9, 0x5a, 0xb6, 0x70, 0xb1, 0xb9, 0x93,
	0xa3, 0x08, 0xf4, 0xf9, 0x75, 0x74, 0x85, 0xf5, 0x40, 0x25, 0x5c, 0x0e, 0x54, 0x62, 0x95, 0x86,
	0x34, 0x58, 0x09, 0x54, 0xe9, 0x6d, 0xa0, 0xff, 0x4f, 0x2c, 0x03, 0x95, 0xb0, 0x1b, 0xa8, 0x42,
	0x2a, 0x81, 0x1a, 0xb4, 0x1e, 0x68, 0xb9, 0x7f, 0x17, 0xbb, 0xab, 0x05, 0x13, 0x68, 0xd9, 0xc2,
	0xc5, 0xe6, 0x06, 0xfa, 0x47, 0x1b, 0xba, 0x67, 0xc5, 0xb2, 0xac, 0xf3, 0x7c, 0x0c, 0xcb, 0x01,
	0xa7, 0x39, 0x92, 0x7d, 0x4f, 0x2d, 0xd7, 0x92, 0x2e, 0x30, 0xeb, 0xe2, 0x52, 0x83, 0xd6, 0x61,
	0x9b, 0x8c, 0x60, 0x4d, 0x94, 0x04, 0xb7, 0x69, 0xb4, 0x48, 0x5a, 0xa1, 0x6e, 0xd3, 0xc8, 0x19,
	0xc8, 0x13, 0x58, 0x91, 0x4d, 0x93, 0x6d, 0x5d, 0x26, 0x9f, 0xb5, 0x7a, 0xa7, 0x0a, 0x6b, 0xe9,
	0xf0, 0xdf, 0x36, 0x74, 0xdf, 0x14, 0x7b, 0x87, 0x1e, 0xc7, 0x33, 0x58, 0x3f, 0x45, 0x3e, 0x0a,
	0x93, 0x44, 0x23, 0xdb, 0x9e, 0xdc, 0x5c, 0x14, 0x6c, 0x53, 0x95, 0xb0, 0x50, 0x3b, 0xcd, 0xfc,
	0x08, 0xbb, 0x45, 0xd9, 0xdb, 0x98, 0x5f, 0x16, 0xd7, 0x8b, 0x30, 0xba, 0xd2, 0x4e, 0x9f, 0x28,
	0x49, 0x95, 0xbf, 0xcb, 0xf2, 0x07, 0xe8, 0x6b, 0xc9, 0x71, 0x96, 0x25, 0xc5, 0xb6, 0x11, 0x53,
	0xb3, 0xce, 0xf5, 0x2b, 0xae, 0x4e, 0xc9, 0x3c, 0xc7, 0xe1, 0x6f, 0x4b, 0x00, 0xc1, 0x79, 0xa0,
	0x2d, 0x9e, 0xc0, 0x7a, 0x80, 0xe9, 0x24, 0x98, 0x31, 0x8d, 0x6c, 0x79, 0xc5, 0x16, 0x2b, 0xc0,
	0xf3, 0xc0, 0x2e, 0x71, 0x02, 0x2c, 0x00, 0x27, 0x7b, 0x21, 0x3d, 0x6f, 0x92, 0x9e, 0x2f, 0x96,
	0xbe, 0x84, 0x7d, 0xf5, 0x56, 0x11, 0x06, 0xcd, 0xe2, 0x84, 0x72, 0x9b, 0x95, 0xd3, 0x80, 0xc3,
	0x2f, 0x32, 0x3c, 0x82, 0x87, 0xa7, 0xc8, 0x03, 0xb3, 0x49, 0x68, 0x2f, 0x22, 0x6a, 0x0b, 0x6a,
	0x61, 0x43, 0xc3, 0x7f, 0x96, 0xe0, 0xc1, 0x89, 0x3a, 0x31, 0xd8, 0xf9, 0xb0, 0x26, 0xd7, 0x84,
	0x13, 0x1a, 0x91, 0x8f, 0x3d, 0x7b, 0xa0, 0x30, 0xa8, 0xdd, 0xd5, 0x2c, 0xa9, 0x5d, 0x06, 0x2d,
	0xf2, 0x0c, 0x56, 0x4e, 0x91, 0x17, 0xea, 0x3d, 0xa7, 0x40, 0x42, 0x76, 0x76, 0xd7, 0x19, 0x33,
	0xaa, 0xef, 0xc4, 0x32, 0x73, 0x9c, 0x24, 0xd5, 0x0e, 0x0c, 0xaa, 0x6d, 0x1e, 0x35, 0x93, 0xae,
	0x93, 0xfc, 0x01, 0x54, 0x9d, 0x0c, 0xda, 0xe4, 0xe4, 0x90, 0xae, 0x93, 0x5c, 0x69, 0xaa, 0x4e,
	0x06, 0x6d, 0x72, 0x72, 0x48, 0x93, 0xf9, 0xdf, 0xf7, 0x60, 0x73, 0x44, 0x93, 0x04, 0x23, 0x77,
	0x4e, 0xbf, 0x83, 0x0d, 0x99, 0xaf, 0xa5, 0xc8, 0xa0, 0x16, 0xbe, 0x25, 0xf5, 0xdb, 0x3e, 0x5f,
	0x58, 0x63, 0xda, 0x7f, 0x05, 0xbd, 0xe2, 0xd7, 0x6c, 0xbd, 0x3f, 0x2d, 0x27, 0x57, 0x37, 0xfe,
	0x6c, 0x7e, 0x81, 0x71, 0x7d, 0x07, 0x1b, 0x32, 0xf5, 0x39, 0x4d, 0x57, 0xc9, 0xa6, 0xa6, 0xeb,
	0x35, 0xae, 0xbd, 0xfc, 0x14, 0x73, 0xec, 0xab, 0x64, 0x93, 0x7d, 0xbd, 0xc6, 0xb5, 0x97, 0xdf,
	0x67, 0x8e, 0x7d, 0x95, 0x6c, 0xb2, 0xaf, 0xd7, 0x98, 0xef, 0xfc, 0x3d, 0xf4, 0xc6, 0x98, 0x4e,
	0xec, 0x31, 0xf7, 0x29, 0xac, 0x48, 0x80, 0xec, 0x78, 0xfa, 0x34, 0x2e, 0x01, 0xed, 0xbc, 0x5b,
	0xc3, 0x8d, 0xdb, 0x2f, 0x6d, 0xe8, 0x05, 0xe2, 0xa4, 0x6e, 0xed, 0x3e, 0x1a, 0x63, 0x38, 0x91,
	0x66, 0xea, 0x04, 0x5f, 0x00, 0x25, 0xb3, 0x12, 0xae, 0xcd, 0x0e, 0xdb, 0xe4, 0x08, 0x96, 0xdf,
	0xe6, 0x31, 0x47, 0xe2, 0x56, 0x09, 0x44, 0xcb, 0xf7, 0xea, 0x84, 0xd6, 0x1f, 0xb4, 0x87, 0xbf,
	0xb6, 0x61, 0x3d, 0x88, 0xc2, 0x34, 0xb5, 0xc3, 0x3b, 0x82, 0xd5, 0x31, 0x66, 0x49, 0x18, 0x29,
	0x53, 0x35, 0x0e, 0x81, 0x94, 0x4c, 0xcb, 0x84, 0xb3, 0x96, 0xad, 0xbe, 0xf8, 0xc0, 0xf3, 0x30,
	0xe2, 0x8e, 0x5e, 0x21, 0x75, 0xbd, 0x21, 0x4c, 0x42, 0x53, 0xe8, 0x06, 0x97, 0x68, 0x77, 0xb1,
	0x2f, 0x61, 0x59, 0x3c, 0x93, 0x55, 0x8f, 0x32, 0x6f, 0x34, 0x9b, 0x2c, 0x4e, 0xe4, 0x00, 0x56,
	0x47, 0x34, 0xe5, 0xf8, 0x81, 0x93, 0x75, 0xfb, 0x96, 0x59, 0xc6, 0x6f, 0xfb, 0x1d, 0x61, 0x20,
	0xc9, 0x41, 0xeb, 0x62, 0x45, 0xfc, 0x17, 0xf4, 0xd5, 0x7f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x36,
	0x3c, 0x39, 0xef, 0x04, 0x0e, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// CertificateServiceClient is the client API for CertificateService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CertificateServiceClient interface {
	Register(ctx context.Context, in *auth.CSR, opts ...grpc.CallOption) (*auth.Certificate, error)
}

type certificateServiceClient struct {
	cc *grpc.ClientConn
}

func NewCertificateServiceClient(cc *grpc.ClientConn) CertificateServiceClient {
	return &certificateServiceClient{cc}
}

func (c *certificateServiceClient) Register(ctx context.Context, in *auth.CSR, opts ...grpc.CallOption) (*auth.Certificate, error) {
	out := new(auth.Certificate)
	err := c.cc.Invoke(ctx, "/api.CertificateService/Register", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CertificateServiceServer is the server API for CertificateService service.
type CertificateServiceServer interface {
	Register(context.Context, *auth.CSR) (*auth.Certificate, error)
}

func RegisterCertificateServiceServer(s *grpc.Server, srv CertificateServiceServer) {
	s.RegisterService(&_CertificateService_serviceDesc, srv)
}

func _CertificateService_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(auth.CSR)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertificateServiceServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.CertificateService/Register",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertificateServiceServer).Register(ctx, req.(*auth.CSR))
	}
	return interceptor(ctx, in, info, handler)
}

var _CertificateService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.CertificateService",
	HandlerType: (*CertificateServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Register",
			Handler:    _CertificateService_Register_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/api.proto",
}

// UserServiceClient is the client API for UserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type UserServiceClient interface {
	CreateUser(ctx context.Context, in *auth.User, opts ...grpc.CallOption) (*auth.UserRecord, error)
	Update(ctx context.Context, in *auth.User, opts ...grpc.CallOption) (*auth.UserRecord, error)
	DeleteUser(ctx context.Context, in *auth.DeleteUserRequest, opts ...grpc.CallOption) (*errors.Error, error)
	GetUser(ctx context.Context, in *auth.GetUserByID, opts ...grpc.CallOption) (*auth.UserRecord, error)
	GetUsers(ctx context.Context, in *auth.UsersRequest, opts ...grpc.CallOption) (*auth.UsersIterator, error)
	SetUserClaims(ctx context.Context, in *auth.SetUserClaimsRequest, opts ...grpc.CallOption) (*errors.Error, error)
}

type userServiceClient struct {
	cc *grpc.ClientConn
}

func NewUserServiceClient(cc *grpc.ClientConn) UserServiceClient {
	return &userServiceClient{cc}
}

func (c *userServiceClient) CreateUser(ctx context.Context, in *auth.User, opts ...grpc.CallOption) (*auth.UserRecord, error) {
	out := new(auth.UserRecord)
	err := c.cc.Invoke(ctx, "/api.UserService/CreateUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) Update(ctx context.Context, in *auth.User, opts ...grpc.CallOption) (*auth.UserRecord, error) {
	out := new(auth.UserRecord)
	err := c.cc.Invoke(ctx, "/api.UserService/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) DeleteUser(ctx context.Context, in *auth.DeleteUserRequest, opts ...grpc.CallOption) (*errors.Error, error) {
	out := new(errors.Error)
	err := c.cc.Invoke(ctx, "/api.UserService/DeleteUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetUser(ctx context.Context, in *auth.GetUserByID, opts ...grpc.CallOption) (*auth.UserRecord, error) {
	out := new(auth.UserRecord)
	err := c.cc.Invoke(ctx, "/api.UserService/GetUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetUsers(ctx context.Context, in *auth.UsersRequest, opts ...grpc.CallOption) (*auth.UsersIterator, error) {
	out := new(auth.UsersIterator)
	err := c.cc.Invoke(ctx, "/api.UserService/GetUsers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) SetUserClaims(ctx context.Context, in *auth.SetUserClaimsRequest, opts ...grpc.CallOption) (*errors.Error, error) {
	out := new(errors.Error)
	err := c.cc.Invoke(ctx, "/api.UserService/SetUserClaims", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServiceServer is the server API for UserService service.
type UserServiceServer interface {
	CreateUser(context.Context, *auth.User) (*auth.UserRecord, error)
	Update(context.Context, *auth.User) (*auth.UserRecord, error)
	DeleteUser(context.Context, *auth.DeleteUserRequest) (*errors.Error, error)
	GetUser(context.Context, *auth.GetUserByID) (*auth.UserRecord, error)
	GetUsers(context.Context, *auth.UsersRequest) (*auth.UsersIterator, error)
	SetUserClaims(context.Context, *auth.SetUserClaimsRequest) (*errors.Error, error)
}

func RegisterUserServiceServer(s *grpc.Server, srv UserServiceServer) {
	s.RegisterService(&_UserService_serviceDesc, srv)
}

func _UserService_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(auth.User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.UserService/CreateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).CreateUser(ctx, req.(*auth.User))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(auth.User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.UserService/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).Update(ctx, req.(*auth.User))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(auth.DeleteUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.UserService/DeleteUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).DeleteUser(ctx, req.(*auth.DeleteUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(auth.GetUserByID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.UserService/GetUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUser(ctx, req.(*auth.GetUserByID))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(auth.UsersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.UserService/GetUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUsers(ctx, req.(*auth.UsersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_SetUserClaims_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(auth.SetUserClaimsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).SetUserClaims(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.UserService/SetUserClaims",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).SetUserClaims(ctx, req.(*auth.SetUserClaimsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _UserService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.UserService",
	HandlerType: (*UserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateUser",
			Handler:    _UserService_CreateUser_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _UserService_Update_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _UserService_DeleteUser_Handler,
		},
		{
			MethodName: "GetUser",
			Handler:    _UserService_GetUser_Handler,
		},
		{
			MethodName: "GetUsers",
			Handler:    _UserService_GetUsers_Handler,
		},
		{
			MethodName: "SetUserClaims",
			Handler:    _UserService_SetUserClaims_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/api.proto",
}

// TokenServiceClient is the client API for TokenService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TokenServiceClient interface {
	CustomToken(ctx context.Context, in *auth.CustomTokenRequest, opts ...grpc.CallOption) (*auth.CustomTokenResponse, error)
	RevokeToken(ctx context.Context, in *auth.RevokeTokenRequest, opts ...grpc.CallOption) (*auth.UserRecord, error)
	VerifyToken(ctx context.Context, in *auth.VerifyTokenRequest, opts ...grpc.CallOption) (*auth.Token, error)
}

type tokenServiceClient struct {
	cc *grpc.ClientConn
}

func NewTokenServiceClient(cc *grpc.ClientConn) TokenServiceClient {
	return &tokenServiceClient{cc}
}

func (c *tokenServiceClient) CustomToken(ctx context.Context, in *auth.CustomTokenRequest, opts ...grpc.CallOption) (*auth.CustomTokenResponse, error) {
	out := new(auth.CustomTokenResponse)
	err := c.cc.Invoke(ctx, "/api.TokenService/CustomToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tokenServiceClient) RevokeToken(ctx context.Context, in *auth.RevokeTokenRequest, opts ...grpc.CallOption) (*auth.UserRecord, error) {
	out := new(auth.UserRecord)
	err := c.cc.Invoke(ctx, "/api.TokenService/RevokeToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tokenServiceClient) VerifyToken(ctx context.Context, in *auth.VerifyTokenRequest, opts ...grpc.CallOption) (*auth.Token, error) {
	out := new(auth.Token)
	err := c.cc.Invoke(ctx, "/api.TokenService/VerifyToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TokenServiceServer is the server API for TokenService service.
type TokenServiceServer interface {
	CustomToken(context.Context, *auth.CustomTokenRequest) (*auth.CustomTokenResponse, error)
	RevokeToken(context.Context, *auth.RevokeTokenRequest) (*auth.UserRecord, error)
	VerifyToken(context.Context, *auth.VerifyTokenRequest) (*auth.Token, error)
}

func RegisterTokenServiceServer(s *grpc.Server, srv TokenServiceServer) {
	s.RegisterService(&_TokenService_serviceDesc, srv)
}

func _TokenService_CustomToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(auth.CustomTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenServiceServer).CustomToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.TokenService/CustomToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenServiceServer).CustomToken(ctx, req.(*auth.CustomTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TokenService_RevokeToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(auth.RevokeTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenServiceServer).RevokeToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.TokenService/RevokeToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenServiceServer).RevokeToken(ctx, req.(*auth.RevokeTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TokenService_VerifyToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(auth.VerifyTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenServiceServer).VerifyToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.TokenService/VerifyToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenServiceServer).VerifyToken(ctx, req.(*auth.VerifyTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _TokenService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.TokenService",
	HandlerType: (*TokenServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CustomToken",
			Handler:    _TokenService_CustomToken_Handler,
		},
		{
			MethodName: "RevokeToken",
			Handler:    _TokenService_RevokeToken_Handler,
		},
		{
			MethodName: "VerifyToken",
			Handler:    _TokenService_VerifyToken_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/api.proto",
}

// ObjectServiceClient is the client API for ObjectService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ObjectServiceClient interface {
	CreateObject(ctx context.Context, in *blob.CreateObjectRequest, opts ...grpc.CallOption) (*blob.ObjectResponse, error)
	GetObject(ctx context.Context, in *blob.GetObjectRequest, opts ...grpc.CallOption) (*blob.ObjectResponse, error)
	GetObjects(ctx context.Context, in *blob.GetObjectsRequest, opts ...grpc.CallOption) (*blob.ObjectsResponse, error)
	UpdateObject(ctx context.Context, in *blob.UpdateObjectRequest, opts ...grpc.CallOption) (*blob.ObjectResponse, error)
	DeleteObject(ctx context.Context, in *blob.DeleteObjectRequest, opts ...grpc.CallOption) (*errors.Error, error)
}

type objectServiceClient struct {
	cc *grpc.ClientConn
}

func NewObjectServiceClient(cc *grpc.ClientConn) ObjectServiceClient {
	return &objectServiceClient{cc}
}

func (c *objectServiceClient) CreateObject(ctx context.Context, in *blob.CreateObjectRequest, opts ...grpc.CallOption) (*blob.ObjectResponse, error) {
	out := new(blob.ObjectResponse)
	err := c.cc.Invoke(ctx, "/api.ObjectService/CreateObject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectServiceClient) GetObject(ctx context.Context, in *blob.GetObjectRequest, opts ...grpc.CallOption) (*blob.ObjectResponse, error) {
	out := new(blob.ObjectResponse)
	err := c.cc.Invoke(ctx, "/api.ObjectService/GetObject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectServiceClient) GetObjects(ctx context.Context, in *blob.GetObjectsRequest, opts ...grpc.CallOption) (*blob.ObjectsResponse, error) {
	out := new(blob.ObjectsResponse)
	err := c.cc.Invoke(ctx, "/api.ObjectService/GetObjects", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectServiceClient) UpdateObject(ctx context.Context, in *blob.UpdateObjectRequest, opts ...grpc.CallOption) (*blob.ObjectResponse, error) {
	out := new(blob.ObjectResponse)
	err := c.cc.Invoke(ctx, "/api.ObjectService/UpdateObject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectServiceClient) DeleteObject(ctx context.Context, in *blob.DeleteObjectRequest, opts ...grpc.CallOption) (*errors.Error, error) {
	out := new(errors.Error)
	err := c.cc.Invoke(ctx, "/api.ObjectService/DeleteObject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ObjectServiceServer is the server API for ObjectService service.
type ObjectServiceServer interface {
	CreateObject(context.Context, *blob.CreateObjectRequest) (*blob.ObjectResponse, error)
	GetObject(context.Context, *blob.GetObjectRequest) (*blob.ObjectResponse, error)
	GetObjects(context.Context, *blob.GetObjectsRequest) (*blob.ObjectsResponse, error)
	UpdateObject(context.Context, *blob.UpdateObjectRequest) (*blob.ObjectResponse, error)
	DeleteObject(context.Context, *blob.DeleteObjectRequest) (*errors.Error, error)
}

func RegisterObjectServiceServer(s *grpc.Server, srv ObjectServiceServer) {
	s.RegisterService(&_ObjectService_serviceDesc, srv)
}

func _ObjectService_CreateObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(blob.CreateObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectServiceServer).CreateObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.ObjectService/CreateObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectServiceServer).CreateObject(ctx, req.(*blob.CreateObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectService_GetObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(blob.GetObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectServiceServer).GetObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.ObjectService/GetObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectServiceServer).GetObject(ctx, req.(*blob.GetObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectService_GetObjects_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(blob.GetObjectsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectServiceServer).GetObjects(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.ObjectService/GetObjects",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectServiceServer).GetObjects(ctx, req.(*blob.GetObjectsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectService_UpdateObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(blob.UpdateObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectServiceServer).UpdateObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.ObjectService/UpdateObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectServiceServer).UpdateObject(ctx, req.(*blob.UpdateObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectService_DeleteObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(blob.DeleteObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectServiceServer).DeleteObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.ObjectService/DeleteObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectServiceServer).DeleteObject(ctx, req.(*blob.DeleteObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ObjectService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.ObjectService",
	HandlerType: (*ObjectServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateObject",
			Handler:    _ObjectService_CreateObject_Handler,
		},
		{
			MethodName: "GetObject",
			Handler:    _ObjectService_GetObject_Handler,
		},
		{
			MethodName: "GetObjects",
			Handler:    _ObjectService_GetObjects_Handler,
		},
		{
			MethodName: "UpdateObject",
			Handler:    _ObjectService_UpdateObject_Handler,
		},
		{
			MethodName: "DeleteObject",
			Handler:    _ObjectService_DeleteObject_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/api.proto",
}

// BucketServiceClient is the client API for BucketService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type BucketServiceClient interface {
	CreateBucket(ctx context.Context, in *blob.CreateBucketRequest, opts ...grpc.CallOption) (*blob.BucketResponse, error)
	GetBucket(ctx context.Context, in *blob.GetBucketRequest, opts ...grpc.CallOption) (*blob.BucketResponse, error)
	GetBuckets(ctx context.Context, in *blob.GetBucketsRequest, opts ...grpc.CallOption) (*blob.BucketsResponse, error)
	UpdateBucket(ctx context.Context, in *blob.UpdateBucketRequest, opts ...grpc.CallOption) (*blob.BucketResponse, error)
	DeleteBucket(ctx context.Context, in *blob.DeleteBucketRequest, opts ...grpc.CallOption) (*errors.Error, error)
}

type bucketServiceClient struct {
	cc *grpc.ClientConn
}

func NewBucketServiceClient(cc *grpc.ClientConn) BucketServiceClient {
	return &bucketServiceClient{cc}
}

func (c *bucketServiceClient) CreateBucket(ctx context.Context, in *blob.CreateBucketRequest, opts ...grpc.CallOption) (*blob.BucketResponse, error) {
	out := new(blob.BucketResponse)
	err := c.cc.Invoke(ctx, "/api.BucketService/CreateBucket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bucketServiceClient) GetBucket(ctx context.Context, in *blob.GetBucketRequest, opts ...grpc.CallOption) (*blob.BucketResponse, error) {
	out := new(blob.BucketResponse)
	err := c.cc.Invoke(ctx, "/api.BucketService/GetBucket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bucketServiceClient) GetBuckets(ctx context.Context, in *blob.GetBucketsRequest, opts ...grpc.CallOption) (*blob.BucketsResponse, error) {
	out := new(blob.BucketsResponse)
	err := c.cc.Invoke(ctx, "/api.BucketService/GetBuckets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bucketServiceClient) UpdateBucket(ctx context.Context, in *blob.UpdateBucketRequest, opts ...grpc.CallOption) (*blob.BucketResponse, error) {
	out := new(blob.BucketResponse)
	err := c.cc.Invoke(ctx, "/api.BucketService/UpdateBucket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bucketServiceClient) DeleteBucket(ctx context.Context, in *blob.DeleteBucketRequest, opts ...grpc.CallOption) (*errors.Error, error) {
	out := new(errors.Error)
	err := c.cc.Invoke(ctx, "/api.BucketService/DeleteBucket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BucketServiceServer is the server API for BucketService service.
type BucketServiceServer interface {
	CreateBucket(context.Context, *blob.CreateBucketRequest) (*blob.BucketResponse, error)
	GetBucket(context.Context, *blob.GetBucketRequest) (*blob.BucketResponse, error)
	GetBuckets(context.Context, *blob.GetBucketsRequest) (*blob.BucketsResponse, error)
	UpdateBucket(context.Context, *blob.UpdateBucketRequest) (*blob.BucketResponse, error)
	DeleteBucket(context.Context, *blob.DeleteBucketRequest) (*errors.Error, error)
}

func RegisterBucketServiceServer(s *grpc.Server, srv BucketServiceServer) {
	s.RegisterService(&_BucketService_serviceDesc, srv)
}

func _BucketService_CreateBucket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(blob.CreateBucketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BucketServiceServer).CreateBucket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.BucketService/CreateBucket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BucketServiceServer).CreateBucket(ctx, req.(*blob.CreateBucketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BucketService_GetBucket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(blob.GetBucketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BucketServiceServer).GetBucket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.BucketService/GetBucket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BucketServiceServer).GetBucket(ctx, req.(*blob.GetBucketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BucketService_GetBuckets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(blob.GetBucketsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BucketServiceServer).GetBuckets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.BucketService/GetBuckets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BucketServiceServer).GetBuckets(ctx, req.(*blob.GetBucketsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BucketService_UpdateBucket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(blob.UpdateBucketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BucketServiceServer).UpdateBucket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.BucketService/UpdateBucket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BucketServiceServer).UpdateBucket(ctx, req.(*blob.UpdateBucketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BucketService_DeleteBucket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(blob.DeleteBucketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BucketServiceServer).DeleteBucket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.BucketService/DeleteBucket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BucketServiceServer).DeleteBucket(ctx, req.(*blob.DeleteBucketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _BucketService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.BucketService",
	HandlerType: (*BucketServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateBucket",
			Handler:    _BucketService_CreateBucket_Handler,
		},
		{
			MethodName: "GetBucket",
			Handler:    _BucketService_GetBucket_Handler,
		},
		{
			MethodName: "GetBuckets",
			Handler:    _BucketService_GetBuckets_Handler,
		},
		{
			MethodName: "UpdateBucket",
			Handler:    _BucketService_UpdateBucket_Handler,
		},
		{
			MethodName: "DeleteBucket",
			Handler:    _BucketService_DeleteBucket_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/api.proto",
}

// ImageServiceClient is the client API for ImageService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ImageServiceClient interface {
	Store(ctx context.Context, in *images.ImageStoreRequest, opts ...grpc.CallOption) (ImageService_StoreClient, error)
	StoreSync(ctx context.Context, in *images.ImageStoreRequest, opts ...grpc.CallOption) (*images.ImageSyncResponse, error)
	Delete(ctx context.Context, in *images.DeleteRequest, opts ...grpc.CallOption) (*images.DeleteResponse, error)
}

type imageServiceClient struct {
	cc *grpc.ClientConn
}

func NewImageServiceClient(cc *grpc.ClientConn) ImageServiceClient {
	return &imageServiceClient{cc}
}

func (c *imageServiceClient) Store(ctx context.Context, in *images.ImageStoreRequest, opts ...grpc.CallOption) (ImageService_StoreClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ImageService_serviceDesc.Streams[0], "/api.ImageService/Store", opts...)
	if err != nil {
		return nil, err
	}
	x := &imageServiceStoreClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ImageService_StoreClient interface {
	Recv() (*images.Image, error)
	grpc.ClientStream
}

type imageServiceStoreClient struct {
	grpc.ClientStream
}

func (x *imageServiceStoreClient) Recv() (*images.Image, error) {
	m := new(images.Image)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *imageServiceClient) StoreSync(ctx context.Context, in *images.ImageStoreRequest, opts ...grpc.CallOption) (*images.ImageSyncResponse, error) {
	out := new(images.ImageSyncResponse)
	err := c.cc.Invoke(ctx, "/api.ImageService/StoreSync", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imageServiceClient) Delete(ctx context.Context, in *images.DeleteRequest, opts ...grpc.CallOption) (*images.DeleteResponse, error) {
	out := new(images.DeleteResponse)
	err := c.cc.Invoke(ctx, "/api.ImageService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ImageServiceServer is the server API for ImageService service.
type ImageServiceServer interface {
	Store(*images.ImageStoreRequest, ImageService_StoreServer) error
	StoreSync(context.Context, *images.ImageStoreRequest) (*images.ImageSyncResponse, error)
	Delete(context.Context, *images.DeleteRequest) (*images.DeleteResponse, error)
}

func RegisterImageServiceServer(s *grpc.Server, srv ImageServiceServer) {
	s.RegisterService(&_ImageService_serviceDesc, srv)
}

func _ImageService_Store_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(images.ImageStoreRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ImageServiceServer).Store(m, &imageServiceStoreServer{stream})
}

type ImageService_StoreServer interface {
	Send(*images.Image) error
	grpc.ServerStream
}

type imageServiceStoreServer struct {
	grpc.ServerStream
}

func (x *imageServiceStoreServer) Send(m *images.Image) error {
	return x.ServerStream.SendMsg(m)
}

func _ImageService_StoreSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(images.ImageStoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageServiceServer).StoreSync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.ImageService/StoreSync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageServiceServer).StoreSync(ctx, req.(*images.ImageStoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImageService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(images.DeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.ImageService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageServiceServer).Delete(ctx, req.(*images.DeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ImageService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.ImageService",
	HandlerType: (*ImageServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StoreSync",
			Handler:    _ImageService_StoreSync_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _ImageService_Delete_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Store",
			Handler:       _ImageService_Store_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api/api.proto",
}

// VoiceServiceClient is the client API for VoiceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type VoiceServiceClient interface {
	GetCallService(ctx context.Context, in *voice.GetCallRequest, opts ...grpc.CallOption) (*voice.VoiceResponse, error)
	CallWithCallbackService(ctx context.Context, in *voice.CallWithCallbackRequest, opts ...grpc.CallOption) (*voice.VoiceResponse, error)
	CallWithApplicationService(ctx context.Context, in *voice.CallWithApplication, opts ...grpc.CallOption) (*voice.VoiceResponse, error)
}

type voiceServiceClient struct {
	cc *grpc.ClientConn
}

func NewVoiceServiceClient(cc *grpc.ClientConn) VoiceServiceClient {
	return &voiceServiceClient{cc}
}

func (c *voiceServiceClient) GetCallService(ctx context.Context, in *voice.GetCallRequest, opts ...grpc.CallOption) (*voice.VoiceResponse, error) {
	out := new(voice.VoiceResponse)
	err := c.cc.Invoke(ctx, "/api.VoiceService/GetCallService", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *voiceServiceClient) CallWithCallbackService(ctx context.Context, in *voice.CallWithCallbackRequest, opts ...grpc.CallOption) (*voice.VoiceResponse, error) {
	out := new(voice.VoiceResponse)
	err := c.cc.Invoke(ctx, "/api.VoiceService/CallWithCallbackService", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *voiceServiceClient) CallWithApplicationService(ctx context.Context, in *voice.CallWithApplication, opts ...grpc.CallOption) (*voice.VoiceResponse, error) {
	out := new(voice.VoiceResponse)
	err := c.cc.Invoke(ctx, "/api.VoiceService/CallWithApplicationService", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VoiceServiceServer is the server API for VoiceService service.
type VoiceServiceServer interface {
	GetCallService(context.Context, *voice.GetCallRequest) (*voice.VoiceResponse, error)
	CallWithCallbackService(context.Context, *voice.CallWithCallbackRequest) (*voice.VoiceResponse, error)
	CallWithApplicationService(context.Context, *voice.CallWithApplication) (*voice.VoiceResponse, error)
}

func RegisterVoiceServiceServer(s *grpc.Server, srv VoiceServiceServer) {
	s.RegisterService(&_VoiceService_serviceDesc, srv)
}

func _VoiceService_GetCallService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(voice.GetCallRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VoiceServiceServer).GetCallService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.VoiceService/GetCallService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VoiceServiceServer).GetCallService(ctx, req.(*voice.GetCallRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VoiceService_CallWithCallbackService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(voice.CallWithCallbackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VoiceServiceServer).CallWithCallbackService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.VoiceService/CallWithCallbackService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VoiceServiceServer).CallWithCallbackService(ctx, req.(*voice.CallWithCallbackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VoiceService_CallWithApplicationService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(voice.CallWithApplication)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VoiceServiceServer).CallWithApplicationService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.VoiceService/CallWithApplicationService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VoiceServiceServer).CallWithApplicationService(ctx, req.(*voice.CallWithApplication))
	}
	return interceptor(ctx, in, info, handler)
}

var _VoiceService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.VoiceService",
	HandlerType: (*VoiceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCallService",
			Handler:    _VoiceService_GetCallService_Handler,
		},
		{
			MethodName: "CallWithCallbackService",
			Handler:    _VoiceService_CallWithCallbackService_Handler,
		},
		{
			MethodName: "CallWithApplicationService",
			Handler:    _VoiceService_CallWithApplicationService_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/api.proto",
}

// SMSServiceClient is the client API for SMSService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SMSServiceClient interface {
	SendSmsService(ctx context.Context, in *sms.SendSMSRequest, opts ...grpc.CallOption) (*sms.SMSResponse, error)
	SendMmsService(ctx context.Context, in *sms.SendMMSRequest, opts ...grpc.CallOption) (*sms.SMSResponse, error)
	SendSmsWithCopilotService(ctx context.Context, in *sms.SendSMSWithCopilotRequest, opts ...grpc.CallOption) (*sms.SMSResponse, error)
	GetSmsRequestService(ctx context.Context, in *sms.GetSMSRequest, opts ...grpc.CallOption) (*sms.SMSResponse, error)
}

type sMSServiceClient struct {
	cc *grpc.ClientConn
}

func NewSMSServiceClient(cc *grpc.ClientConn) SMSServiceClient {
	return &sMSServiceClient{cc}
}

func (c *sMSServiceClient) SendSmsService(ctx context.Context, in *sms.SendSMSRequest, opts ...grpc.CallOption) (*sms.SMSResponse, error) {
	out := new(sms.SMSResponse)
	err := c.cc.Invoke(ctx, "/api.SMSService/SendSmsService", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sMSServiceClient) SendMmsService(ctx context.Context, in *sms.SendMMSRequest, opts ...grpc.CallOption) (*sms.SMSResponse, error) {
	out := new(sms.SMSResponse)
	err := c.cc.Invoke(ctx, "/api.SMSService/SendMmsService", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sMSServiceClient) SendSmsWithCopilotService(ctx context.Context, in *sms.SendSMSWithCopilotRequest, opts ...grpc.CallOption) (*sms.SMSResponse, error) {
	out := new(sms.SMSResponse)
	err := c.cc.Invoke(ctx, "/api.SMSService/SendSmsWithCopilotService", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sMSServiceClient) GetSmsRequestService(ctx context.Context, in *sms.GetSMSRequest, opts ...grpc.CallOption) (*sms.SMSResponse, error) {
	out := new(sms.SMSResponse)
	err := c.cc.Invoke(ctx, "/api.SMSService/GetSmsRequestService", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SMSServiceServer is the server API for SMSService service.
type SMSServiceServer interface {
	SendSmsService(context.Context, *sms.SendSMSRequest) (*sms.SMSResponse, error)
	SendMmsService(context.Context, *sms.SendMMSRequest) (*sms.SMSResponse, error)
	SendSmsWithCopilotService(context.Context, *sms.SendSMSWithCopilotRequest) (*sms.SMSResponse, error)
	GetSmsRequestService(context.Context, *sms.GetSMSRequest) (*sms.SMSResponse, error)
}

func RegisterSMSServiceServer(s *grpc.Server, srv SMSServiceServer) {
	s.RegisterService(&_SMSService_serviceDesc, srv)
}

func _SMSService_SendSmsService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(sms.SendSMSRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SMSServiceServer).SendSmsService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.SMSService/SendSmsService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SMSServiceServer).SendSmsService(ctx, req.(*sms.SendSMSRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SMSService_SendMmsService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(sms.SendMMSRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SMSServiceServer).SendMmsService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.SMSService/SendMmsService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SMSServiceServer).SendMmsService(ctx, req.(*sms.SendMMSRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SMSService_SendSmsWithCopilotService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(sms.SendSMSWithCopilotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SMSServiceServer).SendSmsWithCopilotService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.SMSService/SendSmsWithCopilotService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SMSServiceServer).SendSmsWithCopilotService(ctx, req.(*sms.SendSMSWithCopilotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SMSService_GetSmsRequestService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(sms.GetSMSRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SMSServiceServer).GetSmsRequestService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.SMSService/GetSmsRequestService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SMSServiceServer).GetSmsRequestService(ctx, req.(*sms.GetSMSRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _SMSService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.SMSService",
	HandlerType: (*SMSServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendSmsService",
			Handler:    _SMSService_SendSmsService_Handler,
		},
		{
			MethodName: "SendMmsService",
			Handler:    _SMSService_SendMmsService_Handler,
		},
		{
			MethodName: "SendSmsWithCopilotService",
			Handler:    _SMSService_SendSmsWithCopilotService_Handler,
		},
		{
			MethodName: "GetSmsRequestService",
			Handler:    _SMSService_GetSmsRequestService_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/api.proto",
}

// DocumentServiceClient is the client API for DocumentService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type DocumentServiceClient interface {
	CreateDoc(ctx context.Context, in *documents.CreateDocRequest, opts ...grpc.CallOption) (*documents.Document, error)
	GetDoc(ctx context.Context, in *documents.GetDocRequest, opts ...grpc.CallOption) (*documents.GetDocResponse, error)
	GetAllDoc(ctx context.Context, in *documents.GetAllDocRequest, opts ...grpc.CallOption) (*documents.GetAllDocResponse, error)
	DeleteDoc(ctx context.Context, in *documents.DeleteDocRequest, opts ...grpc.CallOption) (*documents.DeleteDocResponse, error)
	UpdateDoc(ctx context.Context, in *documents.UpdateDocRequest, opts ...grpc.CallOption) (*documents.UpdateDocResponse, error)
}

type documentServiceClient struct {
	cc *grpc.ClientConn
}

func NewDocumentServiceClient(cc *grpc.ClientConn) DocumentServiceClient {
	return &documentServiceClient{cc}
}

func (c *documentServiceClient) CreateDoc(ctx context.Context, in *documents.CreateDocRequest, opts ...grpc.CallOption) (*documents.Document, error) {
	out := new(documents.Document)
	err := c.cc.Invoke(ctx, "/api.DocumentService/CreateDoc", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentServiceClient) GetDoc(ctx context.Context, in *documents.GetDocRequest, opts ...grpc.CallOption) (*documents.GetDocResponse, error) {
	out := new(documents.GetDocResponse)
	err := c.cc.Invoke(ctx, "/api.DocumentService/GetDoc", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentServiceClient) GetAllDoc(ctx context.Context, in *documents.GetAllDocRequest, opts ...grpc.CallOption) (*documents.GetAllDocResponse, error) {
	out := new(documents.GetAllDocResponse)
	err := c.cc.Invoke(ctx, "/api.DocumentService/GetAllDoc", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentServiceClient) DeleteDoc(ctx context.Context, in *documents.DeleteDocRequest, opts ...grpc.CallOption) (*documents.DeleteDocResponse, error) {
	out := new(documents.DeleteDocResponse)
	err := c.cc.Invoke(ctx, "/api.DocumentService/DeleteDoc", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentServiceClient) UpdateDoc(ctx context.Context, in *documents.UpdateDocRequest, opts ...grpc.CallOption) (*documents.UpdateDocResponse, error) {
	out := new(documents.UpdateDocResponse)
	err := c.cc.Invoke(ctx, "/api.DocumentService/UpdateDoc", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DocumentServiceServer is the server API for DocumentService service.
type DocumentServiceServer interface {
	CreateDoc(context.Context, *documents.CreateDocRequest) (*documents.Document, error)
	GetDoc(context.Context, *documents.GetDocRequest) (*documents.GetDocResponse, error)
	GetAllDoc(context.Context, *documents.GetAllDocRequest) (*documents.GetAllDocResponse, error)
	DeleteDoc(context.Context, *documents.DeleteDocRequest) (*documents.DeleteDocResponse, error)
	UpdateDoc(context.Context, *documents.UpdateDocRequest) (*documents.UpdateDocResponse, error)
}

func RegisterDocumentServiceServer(s *grpc.Server, srv DocumentServiceServer) {
	s.RegisterService(&_DocumentService_serviceDesc, srv)
}

func _DocumentService_CreateDoc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(documents.CreateDocRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentServiceServer).CreateDoc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.DocumentService/CreateDoc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentServiceServer).CreateDoc(ctx, req.(*documents.CreateDocRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocumentService_GetDoc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(documents.GetDocRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentServiceServer).GetDoc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.DocumentService/GetDoc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentServiceServer).GetDoc(ctx, req.(*documents.GetDocRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocumentService_GetAllDoc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(documents.GetAllDocRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentServiceServer).GetAllDoc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.DocumentService/GetAllDoc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentServiceServer).GetAllDoc(ctx, req.(*documents.GetAllDocRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocumentService_DeleteDoc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(documents.DeleteDocRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentServiceServer).DeleteDoc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.DocumentService/DeleteDoc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentServiceServer).DeleteDoc(ctx, req.(*documents.DeleteDocRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocumentService_UpdateDoc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(documents.UpdateDocRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentServiceServer).UpdateDoc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.DocumentService/UpdateDoc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentServiceServer).UpdateDoc(ctx, req.(*documents.UpdateDocRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _DocumentService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.DocumentService",
	HandlerType: (*DocumentServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateDoc",
			Handler:    _DocumentService_CreateDoc_Handler,
		},
		{
			MethodName: "GetDoc",
			Handler:    _DocumentService_GetDoc_Handler,
		},
		{
			MethodName: "GetAllDoc",
			Handler:    _DocumentService_GetAllDoc_Handler,
		},
		{
			MethodName: "DeleteDoc",
			Handler:    _DocumentService_DeleteDoc_Handler,
		},
		{
			MethodName: "UpdateDoc",
			Handler:    _DocumentService_UpdateDoc_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/api.proto",
}

// CollectionServiceClient is the client API for CollectionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CollectionServiceClient interface {
	CreateCollection(ctx context.Context, in *documents.CreateCollectionRequest, opts ...grpc.CallOption) (*documents.CreateCollectionResponse, error)
	GetCollection(ctx context.Context, in *documents.GetCollectionRequest, opts ...grpc.CallOption) (*documents.GetCollectionResponse, error)
	GetAllCollection(ctx context.Context, in *documents.GetAllCollectionRequest, opts ...grpc.CallOption) (*documents.GetAllCollectionResponse, error)
	DeleteCollection(ctx context.Context, in *documents.DeleteCollectionRequest, opts ...grpc.CallOption) (*documents.DeleteCollectionResponse, error)
	UpdateCollection(ctx context.Context, in *documents.UpdateCollectionRequest, opts ...grpc.CallOption) (*documents.UpdateCollectionResponse, error)
}

type collectionServiceClient struct {
	cc *grpc.ClientConn
}

func NewCollectionServiceClient(cc *grpc.ClientConn) CollectionServiceClient {
	return &collectionServiceClient{cc}
}

func (c *collectionServiceClient) CreateCollection(ctx context.Context, in *documents.CreateCollectionRequest, opts ...grpc.CallOption) (*documents.CreateCollectionResponse, error) {
	out := new(documents.CreateCollectionResponse)
	err := c.cc.Invoke(ctx, "/api.CollectionService/CreateCollection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *collectionServiceClient) GetCollection(ctx context.Context, in *documents.GetCollectionRequest, opts ...grpc.CallOption) (*documents.GetCollectionResponse, error) {
	out := new(documents.GetCollectionResponse)
	err := c.cc.Invoke(ctx, "/api.CollectionService/GetCollection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *collectionServiceClient) GetAllCollection(ctx context.Context, in *documents.GetAllCollectionRequest, opts ...grpc.CallOption) (*documents.GetAllCollectionResponse, error) {
	out := new(documents.GetAllCollectionResponse)
	err := c.cc.Invoke(ctx, "/api.CollectionService/GetAllCollection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *collectionServiceClient) DeleteCollection(ctx context.Context, in *documents.DeleteCollectionRequest, opts ...grpc.CallOption) (*documents.DeleteCollectionResponse, error) {
	out := new(documents.DeleteCollectionResponse)
	err := c.cc.Invoke(ctx, "/api.CollectionService/DeleteCollection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *collectionServiceClient) UpdateCollection(ctx context.Context, in *documents.UpdateCollectionRequest, opts ...grpc.CallOption) (*documents.UpdateCollectionResponse, error) {
	out := new(documents.UpdateCollectionResponse)
	err := c.cc.Invoke(ctx, "/api.CollectionService/UpdateCollection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CollectionServiceServer is the server API for CollectionService service.
type CollectionServiceServer interface {
	CreateCollection(context.Context, *documents.CreateCollectionRequest) (*documents.CreateCollectionResponse, error)
	GetCollection(context.Context, *documents.GetCollectionRequest) (*documents.GetCollectionResponse, error)
	GetAllCollection(context.Context, *documents.GetAllCollectionRequest) (*documents.GetAllCollectionResponse, error)
	DeleteCollection(context.Context, *documents.DeleteCollectionRequest) (*documents.DeleteCollectionResponse, error)
	UpdateCollection(context.Context, *documents.UpdateCollectionRequest) (*documents.UpdateCollectionResponse, error)
}

func RegisterCollectionServiceServer(s *grpc.Server, srv CollectionServiceServer) {
	s.RegisterService(&_CollectionService_serviceDesc, srv)
}

func _CollectionService_CreateCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(documents.CreateCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CollectionServiceServer).CreateCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.CollectionService/CreateCollection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CollectionServiceServer).CreateCollection(ctx, req.(*documents.CreateCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CollectionService_GetCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(documents.GetCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CollectionServiceServer).GetCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.CollectionService/GetCollection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CollectionServiceServer).GetCollection(ctx, req.(*documents.GetCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CollectionService_GetAllCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(documents.GetAllCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CollectionServiceServer).GetAllCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.CollectionService/GetAllCollection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CollectionServiceServer).GetAllCollection(ctx, req.(*documents.GetAllCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CollectionService_DeleteCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(documents.DeleteCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CollectionServiceServer).DeleteCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.CollectionService/DeleteCollection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CollectionServiceServer).DeleteCollection(ctx, req.(*documents.DeleteCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CollectionService_UpdateCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(documents.UpdateCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CollectionServiceServer).UpdateCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.CollectionService/UpdateCollection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CollectionServiceServer).UpdateCollection(ctx, req.(*documents.UpdateCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _CollectionService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.CollectionService",
	HandlerType: (*CollectionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateCollection",
			Handler:    _CollectionService_CreateCollection_Handler,
		},
		{
			MethodName: "GetCollection",
			Handler:    _CollectionService_GetCollection_Handler,
		},
		{
			MethodName: "GetAllCollection",
			Handler:    _CollectionService_GetAllCollection_Handler,
		},
		{
			MethodName: "DeleteCollection",
			Handler:    _CollectionService_DeleteCollection_Handler,
		},
		{
			MethodName: "UpdateCollection",
			Handler:    _CollectionService_UpdateCollection_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/api.proto",
}

// RenderServiceClient is the client API for RenderService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RenderServiceClient interface {
	Render(ctx context.Context, in *strings.RenderRequest, opts ...grpc.CallOption) (*strings.RenderResponse, error)
}

type renderServiceClient struct {
	cc *grpc.ClientConn
}

func NewRenderServiceClient(cc *grpc.ClientConn) RenderServiceClient {
	return &renderServiceClient{cc}
}

func (c *renderServiceClient) Render(ctx context.Context, in *strings.RenderRequest, opts ...grpc.CallOption) (*strings.RenderResponse, error) {
	out := new(strings.RenderResponse)
	err := c.cc.Invoke(ctx, "/api.RenderService/Render", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RenderServiceServer is the server API for RenderService service.
type RenderServiceServer interface {
	Render(context.Context, *strings.RenderRequest) (*strings.RenderResponse, error)
}

func RegisterRenderServiceServer(s *grpc.Server, srv RenderServiceServer) {
	s.RegisterService(&_RenderService_serviceDesc, srv)
}

func _RenderService_Render_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(strings.RenderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RenderServiceServer).Render(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.RenderService/Render",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RenderServiceServer).Render(ctx, req.(*strings.RenderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _RenderService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.RenderService",
	HandlerType: (*RenderServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Render",
			Handler:    _RenderService_Render_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/api.proto",
}

// StreamServiceClient is the client API for StreamService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type StreamServiceClient interface {
	Read(ctx context.Context, in *streaming.ReadRequest, opts ...grpc.CallOption) (StreamService_ReadClient, error)
	Write(ctx context.Context, opts ...grpc.CallOption) (StreamService_WriteClient, error)
}

type streamServiceClient struct {
	cc *grpc.ClientConn
}

func NewStreamServiceClient(cc *grpc.ClientConn) StreamServiceClient {
	return &streamServiceClient{cc}
}

func (c *streamServiceClient) Read(ctx context.Context, in *streaming.ReadRequest, opts ...grpc.CallOption) (StreamService_ReadClient, error) {
	stream, err := c.cc.NewStream(ctx, &_StreamService_serviceDesc.Streams[0], "/api.StreamService/Read", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamServiceReadClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type StreamService_ReadClient interface {
	Recv() (*streaming.ReadResponse, error)
	grpc.ClientStream
}

type streamServiceReadClient struct {
	grpc.ClientStream
}

func (x *streamServiceReadClient) Recv() (*streaming.ReadResponse, error) {
	m := new(streaming.ReadResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *streamServiceClient) Write(ctx context.Context, opts ...grpc.CallOption) (StreamService_WriteClient, error) {
	stream, err := c.cc.NewStream(ctx, &_StreamService_serviceDesc.Streams[1], "/api.StreamService/Write", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamServiceWriteClient{stream}
	return x, nil
}

type StreamService_WriteClient interface {
	Send(*streaming.WriteRequest) error
	CloseAndRecv() (*streaming.WriteResponse, error)
	grpc.ClientStream
}

type streamServiceWriteClient struct {
	grpc.ClientStream
}

func (x *streamServiceWriteClient) Send(m *streaming.WriteRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *streamServiceWriteClient) CloseAndRecv() (*streaming.WriteResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(streaming.WriteResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// StreamServiceServer is the server API for StreamService service.
type StreamServiceServer interface {
	Read(*streaming.ReadRequest, StreamService_ReadServer) error
	Write(StreamService_WriteServer) error
}

func RegisterStreamServiceServer(s *grpc.Server, srv StreamServiceServer) {
	s.RegisterService(&_StreamService_serviceDesc, srv)
}

func _StreamService_Read_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(streaming.ReadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StreamServiceServer).Read(m, &streamServiceReadServer{stream})
}

type StreamService_ReadServer interface {
	Send(*streaming.ReadResponse) error
	grpc.ServerStream
}

type streamServiceReadServer struct {
	grpc.ServerStream
}

func (x *streamServiceReadServer) Send(m *streaming.ReadResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _StreamService_Write_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(StreamServiceServer).Write(&streamServiceWriteServer{stream})
}

type StreamService_WriteServer interface {
	SendAndClose(*streaming.WriteResponse) error
	Recv() (*streaming.WriteRequest, error)
	grpc.ServerStream
}

type streamServiceWriteServer struct {
	grpc.ServerStream
}

func (x *streamServiceWriteServer) SendAndClose(m *streaming.WriteResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *streamServiceWriteServer) Recv() (*streaming.WriteRequest, error) {
	m := new(streaming.WriteRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _StreamService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.StreamService",
	HandlerType: (*StreamServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Read",
			Handler:       _StreamService_Read_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Write",
			Handler:       _StreamService_Write_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "api/api.proto",
}

// ScannerServiceClient is the client API for ScannerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ScannerServiceClient interface {
	Replace(ctx context.Context, in *strings.ReplaceRequest, opts ...grpc.CallOption) (*strings.ReplaceResponse, error)
	Extract(ctx context.Context, in *strings.ExtractRequest, opts ...grpc.CallOption) (*strings.ExtractResponse, error)
}

type scannerServiceClient struct {
	cc *grpc.ClientConn
}

func NewScannerServiceClient(cc *grpc.ClientConn) ScannerServiceClient {
	return &scannerServiceClient{cc}
}

func (c *scannerServiceClient) Replace(ctx context.Context, in *strings.ReplaceRequest, opts ...grpc.CallOption) (*strings.ReplaceResponse, error) {
	out := new(strings.ReplaceResponse)
	err := c.cc.Invoke(ctx, "/api.ScannerService/Replace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scannerServiceClient) Extract(ctx context.Context, in *strings.ExtractRequest, opts ...grpc.CallOption) (*strings.ExtractResponse, error) {
	out := new(strings.ExtractResponse)
	err := c.cc.Invoke(ctx, "/api.ScannerService/Extract", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ScannerServiceServer is the server API for ScannerService service.
type ScannerServiceServer interface {
	Replace(context.Context, *strings.ReplaceRequest) (*strings.ReplaceResponse, error)
	Extract(context.Context, *strings.ExtractRequest) (*strings.ExtractResponse, error)
}

func RegisterScannerServiceServer(s *grpc.Server, srv ScannerServiceServer) {
	s.RegisterService(&_ScannerService_serviceDesc, srv)
}

func _ScannerService_Replace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(strings.ReplaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScannerServiceServer).Replace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.ScannerService/Replace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScannerServiceServer).Replace(ctx, req.(*strings.ReplaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScannerService_Extract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(strings.ExtractRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScannerServiceServer).Extract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.ScannerService/Extract",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScannerServiceServer).Extract(ctx, req.(*strings.ExtractRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ScannerService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.ScannerService",
	HandlerType: (*ScannerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Replace",
			Handler:    _ScannerService_Replace_Handler,
		},
		{
			MethodName: "Extract",
			Handler:    _ScannerService_Extract_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/api.proto",
}

// ShellServiceClient is the client API for ShellService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ShellServiceClient interface {
	Shell(ctx context.Context, in *os.Cmd, opts ...grpc.CallOption) (ShellService_ShellClient, error)
	Context(ctx context.Context, in *strings.Empty, opts ...grpc.CallOption) (*os.Context, error)
}

type shellServiceClient struct {
	cc *grpc.ClientConn
}

func NewShellServiceClient(cc *grpc.ClientConn) ShellServiceClient {
	return &shellServiceClient{cc}
}

func (c *shellServiceClient) Shell(ctx context.Context, in *os.Cmd, opts ...grpc.CallOption) (ShellService_ShellClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ShellService_serviceDesc.Streams[0], "/api.ShellService/Shell", opts...)
	if err != nil {
		return nil, err
	}
	x := &shellServiceShellClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ShellService_ShellClient interface {
	Recv() (*streaming.ReadResponse, error)
	grpc.ClientStream
}

type shellServiceShellClient struct {
	grpc.ClientStream
}

func (x *shellServiceShellClient) Recv() (*streaming.ReadResponse, error) {
	m := new(streaming.ReadResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *shellServiceClient) Context(ctx context.Context, in *strings.Empty, opts ...grpc.CallOption) (*os.Context, error) {
	out := new(os.Context)
	err := c.cc.Invoke(ctx, "/api.ShellService/Context", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ShellServiceServer is the server API for ShellService service.
type ShellServiceServer interface {
	Shell(*os.Cmd, ShellService_ShellServer) error
	Context(context.Context, *strings.Empty) (*os.Context, error)
}

func RegisterShellServiceServer(s *grpc.Server, srv ShellServiceServer) {
	s.RegisterService(&_ShellService_serviceDesc, srv)
}

func _ShellService_Shell_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(os.Cmd)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ShellServiceServer).Shell(m, &shellServiceShellServer{stream})
}

type ShellService_ShellServer interface {
	Send(*streaming.ReadResponse) error
	grpc.ServerStream
}

type shellServiceShellServer struct {
	grpc.ServerStream
}

func (x *shellServiceShellServer) Send(m *streaming.ReadResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _ShellService_Context_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(strings.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShellServiceServer).Context(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.ShellService/Context",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShellServiceServer).Context(ctx, req.(*strings.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _ShellService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.ShellService",
	HandlerType: (*ShellServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Context",
			Handler:    _ShellService_Context_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Shell",
			Handler:       _ShellService_Shell_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api/api.proto",
}
