// Code generated by protoc-gen-go. DO NOT EDIT.
// source: saas/saas.proto

package saas

import (
	context "context"
	fmt "fmt"
	auth "github.com/autom8ter/api/sdk/go/auth"
	documents "github.com/autom8ter/api/sdk/go/documents"
	images "github.com/autom8ter/api/sdk/go/images"
	sms "github.com/autom8ter/api/sdk/go/sms"
	storage "github.com/autom8ter/api/sdk/go/storage"
	streaming "github.com/autom8ter/api/sdk/go/streaming"
	strings "github.com/autom8ter/api/sdk/go/strings"
	voice "github.com/autom8ter/api/sdk/go/voice"
	proto "github.com/golang/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

func init() { proto.RegisterFile("saas/saas.proto", fileDescriptor_6d2d12fcb8d95ba1) }

var fileDescriptor_6d2d12fcb8d95ba1 = []byte{
	// 909 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x96, 0xcb, 0x6e, 0xdb, 0x46,
	0x14, 0x86, 0xa5, 0xc2, 0x91, 0xeb, 0x23, 0x4b, 0x4e, 0xc6, 0x71, 0x6c, 0xab, 0x46, 0x5b, 0xb0,
	0x9b, 0x2c, 0x0a, 0xd1, 0x50, 0x91, 0x16, 0x81, 0x51, 0x07, 0x8e, 0x14, 0xa8, 0x06, 0x2a, 0xa4,
	0x11, 0x73, 0x59, 0x75, 0x31, 0xa6, 0x4e, 0x65, 0xd6, 0x24, 0x87, 0xe5, 0x8c, 0x8c, 0x6a, 0xd9,
	0x65, 0x77, 0x05, 0xfa, 0x48, 0x45, 0xdf, 0xa8, 0x0f, 0x50, 0x90, 0x73, 0xe1, 0xf0, 0x22, 0x65,
	0xc3, 0xcb, 0xff, 0x9f, 0xff, 0xe3, 0xcc, 0xe8, 0x0c, 0x45, 0x38, 0xe0, 0x94, 0x72, 0x37, 0x3b,
	0x0c, 0x93, 0x94, 0x09, 0x46, 0x76, 0xb2, 0xeb, 0xc1, 0xd9, 0x92, 0xb1, 0x65, 0x88, 0x2e, 0x4d,
	0x02, 0x97, 0xc6, 0x31, 0x13, 0x54, 0x04, 0x2c, 0x56, 0x35, 0x83, 0x03, 0xba, 0x12, 0xb7, 0x6e,
	0x76, 0x50, 0xc2, 0x11, 0x17, 0x2c, 0xa5, 0x4b, 0x74, 0xd5, 0x59, 0xc9, 0x87, 0x41, 0x44, 0x97,
	0xc8, 0x5d, 0x79, 0x52, 0x62, 0x8f, 0x47, 0xdc, 0xe5, 0x91, 0xbe, 0x7d, 0x74, 0xcf, 0x02, 0x1f,
	0xdd, 0xfc, 0xa8, 0xa4, 0xd3, 0x05, 0xf3, 0x57, 0x11, 0xc6, 0x82, 0xbb, 0xe6, 0xaa, 0x78, 0x50,
	0x1a, 0xc4, 0x4b, 0xee, 0xaa, 0xb3, 0x4e, 0x70, 0x91, 0x22, 0x8d, 0x82, 0x78, 0xe9, 0x9a, 0x2b,
	0x69, 0x8d, 0xfe, 0xd8, 0x81, 0xee, 0xd5, 0x4a, 0xdc, 0x7a, 0x98, 0xde, 0x07, 0x3e, 0x92, 0xaf,
	0x01, 0xc6, 0x29, 0x52, 0x81, 0xef, 0x38, 0xa6, 0x04, 0x86, 0xf9, 0x2c, 0xb2, 0xeb, 0xc1, 0xc3,
	0xe2, 0x7a, 0x8e, 0x3e, 0x4b, 0x17, 0x4e, 0x8b, 0x3c, 0x85, 0xce, 0xbb, 0x64, 0x41, 0x05, 0x7e,
	0xb4, 0xf2, 0x3b, 0x80, 0x09, 0x86, 0xa8, 0xb8, 0xc7, 0xb2, 0xa2, 0x50, 0xe6, 0xf8, 0xdb, 0x0a,
	0xb9, 0x18, 0xf4, 0x87, 0x7a, 0xe4, 0xaf, 0xa2, 0x44, 0xac, 0x9d, 0x16, 0x39, 0x87, 0xdd, 0x29,
	0x8a, 0x3c, 0xf5, 0x48, 0xa6, 0xd4, 0xed, 0xcb, 0xf5, 0xf5, 0xa4, 0xf1, 0x51, 0xdf, 0x43, 0xcf,
	0x93, 0x25, 0xe3, 0x90, 0x06, 0x11, 0x27, 0x03, 0x59, 0x54, 0x12, 0x37, 0x3f, 0x70, 0x02, 0xdd,
	0xf1, 0x8a, 0x0b, 0x16, 0xbd, 0x65, 0x77, 0x18, 0x93, 0x13, 0x19, 0xb6, 0x24, 0x1d, 0x3d, 0x6d,
	0x70, 0x78, 0xc2, 0x62, 0x8e, 0x4e, 0x8b, 0x5c, 0x40, 0x77, 0x8e, 0xf7, 0xec, 0x0e, 0x4b, 0x14,
	0x4b, 0xd2, 0x94, 0xa6, 0x19, 0x7c, 0x0b, 0xdd, 0xf7, 0x98, 0x06, 0xbf, 0xac, 0x4b, 0x61, 0x4b,
	0xd2, 0xe1, 0xae, 0x74, 0x72, 0xcd, 0x69, 0x91, 0x67, 0xf0, 0xa9, 0x5a, 0x1c, 0x4e, 0x48, 0xc1,
	0x35, 0x93, 0x3d, 0xb4, 0xb4, 0x6b, 0x81, 0x29, 0x15, 0x2c, 0x75, 0x5a, 0xa3, 0x37, 0xd0, 0xf7,
	0x64, 0x63, 0xea, 0x2e, 0x78, 0x01, 0xfb, 0xb2, 0x0b, 0x5e, 0xdf, 0xfc, 0x8a, 0xbe, 0x20, 0x67,
	0x43, 0xdd, 0xb9, 0xb6, 0xac, 0xb1, 0x07, 0xc6, 0x95, 0xba, 0xd3, 0x1a, 0xfd, 0xdb, 0x86, 0xfd,
	0xeb, 0xc8, 0x22, 0x3e, 0x83, 0x07, 0xd9, 0x33, 0x90, 0x9c, 0x0e, 0x55, 0xbb, 0x4b, 0x3b, 0xd3,
	0x34, 0xa7, 0x57, 0xb2, 0x9c, 0xd6, 0x79, 0x9b, 0x8c, 0x61, 0x2f, 0x2f, 0xf1, 0xd6, 0xb1, 0xbf,
	0x2d, 0x5a, 0xb1, 0xd6, 0xb1, 0x6f, 0xfd, 0x16, 0xcf, 0xa1, 0x23, 0x3b, 0x8d, 0x1c, 0xe9, 0x32,
	0x79, 0xaf, 0xd3, 0x4f, 0xaa, 0xb2, 0x8e, 0x8e, 0xfe, 0x6b, 0xc3, 0xfe, 0xfb, 0x6c, 0xef, 0x15,
	0x2b, 0xd3, 0x9f, 0xa2, 0x18, 0xd3, 0x30, 0xd4, 0xca, 0xd1, 0x50, 0x6e, 0x4e, 0x25, 0x6b, 0xe6,
	0x63, 0x25, 0xe7, 0x69, 0x6b, 0x30, 0x6f, 0xe0, 0x38, 0x2b, 0xfb, 0x10, 0x88, 0xdb, 0xec, 0x7c,
	0x43, 0xfd, 0x3b, 0x4d, 0xfa, 0x5c, 0x45, 0xaa, 0xfe, 0xc7, 0x90, 0x3f, 0xc1, 0x40, 0x47, 0xae,
	0x92, 0x24, 0x0c, 0xfc, 0xfc, 0x6d, 0xa4, 0xa9, 0x83, 0x0a, 0xd5, 0x2a, 0xd9, 0x44, 0x1c, 0xfd,
	0xfd, 0x09, 0x80, 0x37, 0xf3, 0x34, 0xe2, 0x39, 0xf4, 0x3d, 0x8c, 0x17, 0x5e, 0xc4, 0xb5, 0x72,
	0x38, 0xcc, 0x5e, 0x51, 0xb9, 0x38, 0xf3, 0x8a, 0x56, 0xce, 0xc5, 0x4c, 0xb0, 0xd6, 0x3e, 0x8f,
	0xce, 0x9a, 0xa2, 0xb3, 0xed, 0xd1, 0xd7, 0x70, 0xaa, 0x9e, 0x9a, 0x2f, 0x06, 0x4b, 0x82, 0x90,
	0x89, 0x62, 0xad, 0xac, 0x01, 0x58, 0xfe, 0x36, 0xe0, 0x25, 0x3c, 0x9e, 0xa2, 0xf0, 0xcc, 0xe6,
	0xd7, 0x2c, 0x92, 0xd7, 0x66, 0xd6, 0xd6, 0x01, 0x8d, 0xfe, 0xe9, 0xc0, 0xc1, 0x44, 0xbd, 0x71,
	0x8b, 0x7e, 0xd8, 0x93, 0x5b, 0x62, 0xc2, 0x7c, 0xf2, 0xd9, 0xb0, 0x78, 0x21, 0x1b, 0xb5, 0xd8,
	0x7c, 0x85, 0xa9, 0x29, 0x4e, 0x8b, 0xbc, 0x80, 0xce, 0x14, 0x45, 0x96, 0x3e, 0xb1, 0x0a, 0xa4,
	0x54, 0x74, 0x77, 0xdd, 0x31, 0xb3, 0xfa, 0x01, 0xf6, 0xa6, 0x28, 0xae, 0xc2, 0xb0, 0x3a, 0x02,
	0xa3, 0x6a, 0xcc, 0x59, 0xb3, 0x69, 0x93, 0xe4, 0x06, 0xa8, 0x92, 0x8c, 0xda, 0x44, 0xb2, 0x4c,
	0x9b, 0x24, 0xff, 0x17, 0xaa, 0x24, 0xa3, 0x36, 0x91, 0x2c, 0xd3, 0x90, 0x7e, 0x86, 0x87, 0x72,
	0x25, 0xc7, 0x2c, 0x0c, 0xd1, 0xcf, 0xba, 0x96, 0x38, 0xb5, 0x65, 0x2e, 0x4c, 0xcd, 0xfd, 0x6a,
	0x6b, 0x8d, 0xc1, 0xbf, 0x85, 0x5e, 0xb6, 0x6f, 0x0b, 0xf6, 0x17, 0xe5, 0x35, 0xaa, 0x83, 0xbf,
	0xdc, 0x5c, 0x60, 0x0f, 0x5a, 0xae, 0xef, 0x86, 0x41, 0x57, 0xcd, 0xa6, 0x41, 0xd7, 0x6b, 0x6c,
	0xbc, 0x5c, 0xf4, 0x0d, 0xf8, 0xaa, 0xd9, 0x84, 0xaf, 0xd7, 0xd8, 0x78, 0xf9, 0x4b, 0x6c, 0xc0,
	0x57, 0xcd, 0x26, 0x7c, 0xbd, 0xc6, 0xec, 0xa2, 0x1f, 0xa1, 0x37, 0xc7, 0x78, 0x81, 0xa9, 0xde,
	0x42, 0x17, 0xd0, 0x91, 0x02, 0x79, 0x62, 0xfe, 0x8c, 0xa5, 0xa0, 0xc9, 0xc7, 0x35, 0xdd, 0xd0,
	0xfe, 0x6c, 0x03, 0xbc, 0x5c, 0x0b, 0xf4, 0xf2, 0xef, 0x1a, 0x72, 0x01, 0x3b, 0x73, 0xa4, 0x0b,
	0x49, 0x52, 0x1f, 0x3a, 0x99, 0x50, 0x22, 0x95, 0x74, 0x4d, 0x3a, 0x6f, 0x93, 0x4b, 0x78, 0xf0,
	0x21, 0x0d, 0x04, 0x12, 0xbb, 0x2a, 0x57, 0x74, 0xfc, 0xa4, 0x6e, 0xe8, 0xfc, 0xd3, 0xf6, 0xe8,
	0xaf, 0x36, 0xf4, 0x3d, 0x9f, 0xc6, 0x71, 0x31, 0xb7, 0x4b, 0xd8, 0x9d, 0x63, 0x12, 0x52, 0x5f,
	0x41, 0xd5, 0x24, 0x72, 0xa5, 0x04, 0x2d, 0x1b, 0xd6, 0x2b, 0x6b, 0xf7, 0xd5, 0xef, 0x22, 0xa5,
	0xbe, 0xb0, 0xf2, 0x4a, 0xa9, 0xe7, 0x8d, 0xa1, 0xf3, 0x37, 0x9d, 0xfc, 0x2b, 0xef, 0x9b, 0xff,
	0x03, 0x00, 0x00, 0xff, 0xff, 0xfb, 0x57, 0xe8, 0x74, 0xc8, 0x0a, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AuthServiceClient is the client API for AuthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AuthServiceClient interface {
	CreateUser(ctx context.Context, in *auth.User, opts ...grpc.CallOption) (*auth.UserRecord, error)
	Update(ctx context.Context, in *auth.User, opts ...grpc.CallOption) (*auth.UserRecord, error)
	DeleteUser(ctx context.Context, in *auth.DeleteUserRequest, opts ...grpc.CallOption) (*strings.Empty, error)
	GetUser(ctx context.Context, in *auth.GetUserByID, opts ...grpc.CallOption) (*auth.UserRecord, error)
	SetUserClaims(ctx context.Context, in *auth.SetUserClaimsRequest, opts ...grpc.CallOption) (*strings.Empty, error)
	CustomToken(ctx context.Context, in *auth.CustomTokenRequest, opts ...grpc.CallOption) (*auth.CustomTokenResponse, error)
	RevokeToken(ctx context.Context, in *auth.RevokeTokenRequest, opts ...grpc.CallOption) (*auth.UserRecord, error)
	VerifyToken(ctx context.Context, in *auth.VerifyTokenRequest, opts ...grpc.CallOption) (*auth.Token, error)
	GetUsers(ctx context.Context, in *auth.UsersRequest, opts ...grpc.CallOption) (*auth.UsersIterator, error)
}

type authServiceClient struct {
	cc *grpc.ClientConn
}

func NewAuthServiceClient(cc *grpc.ClientConn) AuthServiceClient {
	return &authServiceClient{cc}
}

func (c *authServiceClient) CreateUser(ctx context.Context, in *auth.User, opts ...grpc.CallOption) (*auth.UserRecord, error) {
	out := new(auth.UserRecord)
	err := c.cc.Invoke(ctx, "/saas.AuthService/CreateUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) Update(ctx context.Context, in *auth.User, opts ...grpc.CallOption) (*auth.UserRecord, error) {
	out := new(auth.UserRecord)
	err := c.cc.Invoke(ctx, "/saas.AuthService/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteUser(ctx context.Context, in *auth.DeleteUserRequest, opts ...grpc.CallOption) (*strings.Empty, error) {
	out := new(strings.Empty)
	err := c.cc.Invoke(ctx, "/saas.AuthService/DeleteUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetUser(ctx context.Context, in *auth.GetUserByID, opts ...grpc.CallOption) (*auth.UserRecord, error) {
	out := new(auth.UserRecord)
	err := c.cc.Invoke(ctx, "/saas.AuthService/GetUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) SetUserClaims(ctx context.Context, in *auth.SetUserClaimsRequest, opts ...grpc.CallOption) (*strings.Empty, error) {
	out := new(strings.Empty)
	err := c.cc.Invoke(ctx, "/saas.AuthService/SetUserClaims", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) CustomToken(ctx context.Context, in *auth.CustomTokenRequest, opts ...grpc.CallOption) (*auth.CustomTokenResponse, error) {
	out := new(auth.CustomTokenResponse)
	err := c.cc.Invoke(ctx, "/saas.AuthService/CustomToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) RevokeToken(ctx context.Context, in *auth.RevokeTokenRequest, opts ...grpc.CallOption) (*auth.UserRecord, error) {
	out := new(auth.UserRecord)
	err := c.cc.Invoke(ctx, "/saas.AuthService/RevokeToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) VerifyToken(ctx context.Context, in *auth.VerifyTokenRequest, opts ...grpc.CallOption) (*auth.Token, error) {
	out := new(auth.Token)
	err := c.cc.Invoke(ctx, "/saas.AuthService/VerifyToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetUsers(ctx context.Context, in *auth.UsersRequest, opts ...grpc.CallOption) (*auth.UsersIterator, error) {
	out := new(auth.UsersIterator)
	err := c.cc.Invoke(ctx, "/saas.AuthService/GetUsers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthServiceServer is the server API for AuthService service.
type AuthServiceServer interface {
	CreateUser(context.Context, *auth.User) (*auth.UserRecord, error)
	Update(context.Context, *auth.User) (*auth.UserRecord, error)
	DeleteUser(context.Context, *auth.DeleteUserRequest) (*strings.Empty, error)
	GetUser(context.Context, *auth.GetUserByID) (*auth.UserRecord, error)
	SetUserClaims(context.Context, *auth.SetUserClaimsRequest) (*strings.Empty, error)
	CustomToken(context.Context, *auth.CustomTokenRequest) (*auth.CustomTokenResponse, error)
	RevokeToken(context.Context, *auth.RevokeTokenRequest) (*auth.UserRecord, error)
	VerifyToken(context.Context, *auth.VerifyTokenRequest) (*auth.Token, error)
	GetUsers(context.Context, *auth.UsersRequest) (*auth.UsersIterator, error)
}

func RegisterAuthServiceServer(s *grpc.Server, srv AuthServiceServer) {
	s.RegisterService(&_AuthService_serviceDesc, srv)
}

func _AuthService_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(auth.User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/saas.AuthService/CreateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).CreateUser(ctx, req.(*auth.User))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(auth.User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/saas.AuthService/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).Update(ctx, req.(*auth.User))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(auth.DeleteUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/saas.AuthService/DeleteUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteUser(ctx, req.(*auth.DeleteUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(auth.GetUserByID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/saas.AuthService/GetUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetUser(ctx, req.(*auth.GetUserByID))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_SetUserClaims_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(auth.SetUserClaimsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).SetUserClaims(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/saas.AuthService/SetUserClaims",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).SetUserClaims(ctx, req.(*auth.SetUserClaimsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_CustomToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(auth.CustomTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).CustomToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/saas.AuthService/CustomToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).CustomToken(ctx, req.(*auth.CustomTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_RevokeToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(auth.RevokeTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).RevokeToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/saas.AuthService/RevokeToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).RevokeToken(ctx, req.(*auth.RevokeTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_VerifyToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(auth.VerifyTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).VerifyToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/saas.AuthService/VerifyToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).VerifyToken(ctx, req.(*auth.VerifyTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(auth.UsersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/saas.AuthService/GetUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetUsers(ctx, req.(*auth.UsersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _AuthService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "saas.AuthService",
	HandlerType: (*AuthServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateUser",
			Handler:    _AuthService_CreateUser_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _AuthService_Update_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _AuthService_DeleteUser_Handler,
		},
		{
			MethodName: "GetUser",
			Handler:    _AuthService_GetUser_Handler,
		},
		{
			MethodName: "SetUserClaims",
			Handler:    _AuthService_SetUserClaims_Handler,
		},
		{
			MethodName: "CustomToken",
			Handler:    _AuthService_CustomToken_Handler,
		},
		{
			MethodName: "RevokeToken",
			Handler:    _AuthService_RevokeToken_Handler,
		},
		{
			MethodName: "VerifyToken",
			Handler:    _AuthService_VerifyToken_Handler,
		},
		{
			MethodName: "GetUsers",
			Handler:    _AuthService_GetUsers_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "saas/saas.proto",
}

// StorageServiceClient is the client API for StorageService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type StorageServiceClient interface {
	CreateObject(ctx context.Context, in *storage.CreateObjectRequest, opts ...grpc.CallOption) (*storage.Object, error)
}

type storageServiceClient struct {
	cc *grpc.ClientConn
}

func NewStorageServiceClient(cc *grpc.ClientConn) StorageServiceClient {
	return &storageServiceClient{cc}
}

func (c *storageServiceClient) CreateObject(ctx context.Context, in *storage.CreateObjectRequest, opts ...grpc.CallOption) (*storage.Object, error) {
	out := new(storage.Object)
	err := c.cc.Invoke(ctx, "/saas.StorageService/CreateObject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StorageServiceServer is the server API for StorageService service.
type StorageServiceServer interface {
	CreateObject(context.Context, *storage.CreateObjectRequest) (*storage.Object, error)
}

func RegisterStorageServiceServer(s *grpc.Server, srv StorageServiceServer) {
	s.RegisterService(&_StorageService_serviceDesc, srv)
}

func _StorageService_CreateObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(storage.CreateObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServiceServer).CreateObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/saas.StorageService/CreateObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServiceServer).CreateObject(ctx, req.(*storage.CreateObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _StorageService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "saas.StorageService",
	HandlerType: (*StorageServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateObject",
			Handler:    _StorageService_CreateObject_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "saas/saas.proto",
}

// ImageServiceClient is the client API for ImageService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ImageServiceClient interface {
	Store(ctx context.Context, in *images.ImageStoreRequest, opts ...grpc.CallOption) (ImageService_StoreClient, error)
	StoreSync(ctx context.Context, in *images.ImageStoreRequest, opts ...grpc.CallOption) (*images.ImageSyncResponse, error)
	Delete(ctx context.Context, in *images.DeleteRequest, opts ...grpc.CallOption) (*images.DeleteResponse, error)
}

type imageServiceClient struct {
	cc *grpc.ClientConn
}

func NewImageServiceClient(cc *grpc.ClientConn) ImageServiceClient {
	return &imageServiceClient{cc}
}

func (c *imageServiceClient) Store(ctx context.Context, in *images.ImageStoreRequest, opts ...grpc.CallOption) (ImageService_StoreClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ImageService_serviceDesc.Streams[0], "/saas.ImageService/Store", opts...)
	if err != nil {
		return nil, err
	}
	x := &imageServiceStoreClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ImageService_StoreClient interface {
	Recv() (*images.Image, error)
	grpc.ClientStream
}

type imageServiceStoreClient struct {
	grpc.ClientStream
}

func (x *imageServiceStoreClient) Recv() (*images.Image, error) {
	m := new(images.Image)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *imageServiceClient) StoreSync(ctx context.Context, in *images.ImageStoreRequest, opts ...grpc.CallOption) (*images.ImageSyncResponse, error) {
	out := new(images.ImageSyncResponse)
	err := c.cc.Invoke(ctx, "/saas.ImageService/StoreSync", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imageServiceClient) Delete(ctx context.Context, in *images.DeleteRequest, opts ...grpc.CallOption) (*images.DeleteResponse, error) {
	out := new(images.DeleteResponse)
	err := c.cc.Invoke(ctx, "/saas.ImageService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ImageServiceServer is the server API for ImageService service.
type ImageServiceServer interface {
	Store(*images.ImageStoreRequest, ImageService_StoreServer) error
	StoreSync(context.Context, *images.ImageStoreRequest) (*images.ImageSyncResponse, error)
	Delete(context.Context, *images.DeleteRequest) (*images.DeleteResponse, error)
}

func RegisterImageServiceServer(s *grpc.Server, srv ImageServiceServer) {
	s.RegisterService(&_ImageService_serviceDesc, srv)
}

func _ImageService_Store_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(images.ImageStoreRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ImageServiceServer).Store(m, &imageServiceStoreServer{stream})
}

type ImageService_StoreServer interface {
	Send(*images.Image) error
	grpc.ServerStream
}

type imageServiceStoreServer struct {
	grpc.ServerStream
}

func (x *imageServiceStoreServer) Send(m *images.Image) error {
	return x.ServerStream.SendMsg(m)
}

func _ImageService_StoreSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(images.ImageStoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageServiceServer).StoreSync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/saas.ImageService/StoreSync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageServiceServer).StoreSync(ctx, req.(*images.ImageStoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImageService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(images.DeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/saas.ImageService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageServiceServer).Delete(ctx, req.(*images.DeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ImageService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "saas.ImageService",
	HandlerType: (*ImageServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StoreSync",
			Handler:    _ImageService_StoreSync_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _ImageService_Delete_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Store",
			Handler:       _ImageService_Store_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "saas/saas.proto",
}

// VoiceServiceClient is the client API for VoiceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type VoiceServiceClient interface {
	GetCallService(ctx context.Context, in *voice.GetCallRequest, opts ...grpc.CallOption) (*voice.VoiceResponse, error)
	CallWithCallbackService(ctx context.Context, in *voice.CallWithCallbackRequest, opts ...grpc.CallOption) (*voice.VoiceResponse, error)
	CallWithApplicationService(ctx context.Context, in *voice.CallWithApplication, opts ...grpc.CallOption) (*voice.VoiceResponse, error)
}

type voiceServiceClient struct {
	cc *grpc.ClientConn
}

func NewVoiceServiceClient(cc *grpc.ClientConn) VoiceServiceClient {
	return &voiceServiceClient{cc}
}

func (c *voiceServiceClient) GetCallService(ctx context.Context, in *voice.GetCallRequest, opts ...grpc.CallOption) (*voice.VoiceResponse, error) {
	out := new(voice.VoiceResponse)
	err := c.cc.Invoke(ctx, "/saas.VoiceService/GetCallService", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *voiceServiceClient) CallWithCallbackService(ctx context.Context, in *voice.CallWithCallbackRequest, opts ...grpc.CallOption) (*voice.VoiceResponse, error) {
	out := new(voice.VoiceResponse)
	err := c.cc.Invoke(ctx, "/saas.VoiceService/CallWithCallbackService", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *voiceServiceClient) CallWithApplicationService(ctx context.Context, in *voice.CallWithApplication, opts ...grpc.CallOption) (*voice.VoiceResponse, error) {
	out := new(voice.VoiceResponse)
	err := c.cc.Invoke(ctx, "/saas.VoiceService/CallWithApplicationService", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VoiceServiceServer is the server API for VoiceService service.
type VoiceServiceServer interface {
	GetCallService(context.Context, *voice.GetCallRequest) (*voice.VoiceResponse, error)
	CallWithCallbackService(context.Context, *voice.CallWithCallbackRequest) (*voice.VoiceResponse, error)
	CallWithApplicationService(context.Context, *voice.CallWithApplication) (*voice.VoiceResponse, error)
}

func RegisterVoiceServiceServer(s *grpc.Server, srv VoiceServiceServer) {
	s.RegisterService(&_VoiceService_serviceDesc, srv)
}

func _VoiceService_GetCallService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(voice.GetCallRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VoiceServiceServer).GetCallService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/saas.VoiceService/GetCallService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VoiceServiceServer).GetCallService(ctx, req.(*voice.GetCallRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VoiceService_CallWithCallbackService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(voice.CallWithCallbackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VoiceServiceServer).CallWithCallbackService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/saas.VoiceService/CallWithCallbackService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VoiceServiceServer).CallWithCallbackService(ctx, req.(*voice.CallWithCallbackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VoiceService_CallWithApplicationService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(voice.CallWithApplication)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VoiceServiceServer).CallWithApplicationService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/saas.VoiceService/CallWithApplicationService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VoiceServiceServer).CallWithApplicationService(ctx, req.(*voice.CallWithApplication))
	}
	return interceptor(ctx, in, info, handler)
}

var _VoiceService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "saas.VoiceService",
	HandlerType: (*VoiceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCallService",
			Handler:    _VoiceService_GetCallService_Handler,
		},
		{
			MethodName: "CallWithCallbackService",
			Handler:    _VoiceService_CallWithCallbackService_Handler,
		},
		{
			MethodName: "CallWithApplicationService",
			Handler:    _VoiceService_CallWithApplicationService_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "saas/saas.proto",
}

// SMSServiceClient is the client API for SMSService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SMSServiceClient interface {
	SendSmsService(ctx context.Context, in *sms.SendSMSRequest, opts ...grpc.CallOption) (*sms.SMSResponse, error)
	SendMmsService(ctx context.Context, in *sms.SendMMSRequest, opts ...grpc.CallOption) (*sms.SMSResponse, error)
	SendSmsWithCopilotService(ctx context.Context, in *sms.SendSMSWithCopilotRequest, opts ...grpc.CallOption) (*sms.SMSResponse, error)
	GetSmsRequestService(ctx context.Context, in *sms.GetSMSRequest, opts ...grpc.CallOption) (*sms.SMSResponse, error)
}

type sMSServiceClient struct {
	cc *grpc.ClientConn
}

func NewSMSServiceClient(cc *grpc.ClientConn) SMSServiceClient {
	return &sMSServiceClient{cc}
}

func (c *sMSServiceClient) SendSmsService(ctx context.Context, in *sms.SendSMSRequest, opts ...grpc.CallOption) (*sms.SMSResponse, error) {
	out := new(sms.SMSResponse)
	err := c.cc.Invoke(ctx, "/saas.SMSService/SendSmsService", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sMSServiceClient) SendMmsService(ctx context.Context, in *sms.SendMMSRequest, opts ...grpc.CallOption) (*sms.SMSResponse, error) {
	out := new(sms.SMSResponse)
	err := c.cc.Invoke(ctx, "/saas.SMSService/SendMmsService", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sMSServiceClient) SendSmsWithCopilotService(ctx context.Context, in *sms.SendSMSWithCopilotRequest, opts ...grpc.CallOption) (*sms.SMSResponse, error) {
	out := new(sms.SMSResponse)
	err := c.cc.Invoke(ctx, "/saas.SMSService/SendSmsWithCopilotService", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sMSServiceClient) GetSmsRequestService(ctx context.Context, in *sms.GetSMSRequest, opts ...grpc.CallOption) (*sms.SMSResponse, error) {
	out := new(sms.SMSResponse)
	err := c.cc.Invoke(ctx, "/saas.SMSService/GetSmsRequestService", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SMSServiceServer is the server API for SMSService service.
type SMSServiceServer interface {
	SendSmsService(context.Context, *sms.SendSMSRequest) (*sms.SMSResponse, error)
	SendMmsService(context.Context, *sms.SendMMSRequest) (*sms.SMSResponse, error)
	SendSmsWithCopilotService(context.Context, *sms.SendSMSWithCopilotRequest) (*sms.SMSResponse, error)
	GetSmsRequestService(context.Context, *sms.GetSMSRequest) (*sms.SMSResponse, error)
}

func RegisterSMSServiceServer(s *grpc.Server, srv SMSServiceServer) {
	s.RegisterService(&_SMSService_serviceDesc, srv)
}

func _SMSService_SendSmsService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(sms.SendSMSRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SMSServiceServer).SendSmsService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/saas.SMSService/SendSmsService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SMSServiceServer).SendSmsService(ctx, req.(*sms.SendSMSRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SMSService_SendMmsService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(sms.SendMMSRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SMSServiceServer).SendMmsService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/saas.SMSService/SendMmsService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SMSServiceServer).SendMmsService(ctx, req.(*sms.SendMMSRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SMSService_SendSmsWithCopilotService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(sms.SendSMSWithCopilotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SMSServiceServer).SendSmsWithCopilotService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/saas.SMSService/SendSmsWithCopilotService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SMSServiceServer).SendSmsWithCopilotService(ctx, req.(*sms.SendSMSWithCopilotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SMSService_GetSmsRequestService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(sms.GetSMSRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SMSServiceServer).GetSmsRequestService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/saas.SMSService/GetSmsRequestService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SMSServiceServer).GetSmsRequestService(ctx, req.(*sms.GetSMSRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _SMSService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "saas.SMSService",
	HandlerType: (*SMSServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendSmsService",
			Handler:    _SMSService_SendSmsService_Handler,
		},
		{
			MethodName: "SendMmsService",
			Handler:    _SMSService_SendMmsService_Handler,
		},
		{
			MethodName: "SendSmsWithCopilotService",
			Handler:    _SMSService_SendSmsWithCopilotService_Handler,
		},
		{
			MethodName: "GetSmsRequestService",
			Handler:    _SMSService_GetSmsRequestService_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "saas/saas.proto",
}

// DocumentServiceClient is the client API for DocumentService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type DocumentServiceClient interface {
	CreateDoc(ctx context.Context, in *documents.CreateDocRequest, opts ...grpc.CallOption) (*documents.Document, error)
	GetDoc(ctx context.Context, in *documents.GetDocRequest, opts ...grpc.CallOption) (*documents.GetDocResponse, error)
	GetAllDoc(ctx context.Context, in *documents.GetAllDocRequest, opts ...grpc.CallOption) (*documents.GetAllDocResponse, error)
	DeleteDoc(ctx context.Context, in *documents.DeleteDocRequest, opts ...grpc.CallOption) (*documents.DeleteDocResponse, error)
	UpdateDoc(ctx context.Context, in *documents.UpdateDocRequest, opts ...grpc.CallOption) (*documents.UpdateDocResponse, error)
	CreateCollection(ctx context.Context, in *documents.CreateCollectionRequest, opts ...grpc.CallOption) (*documents.CreateCollectionResponse, error)
	GetCollection(ctx context.Context, in *documents.GetCollectionRequest, opts ...grpc.CallOption) (*documents.GetCollectionResponse, error)
	GetAllCollection(ctx context.Context, in *documents.GetAllCollectionRequest, opts ...grpc.CallOption) (*documents.GetAllCollectionResponse, error)
	DeleteCollection(ctx context.Context, in *documents.DeleteCollectionRequest, opts ...grpc.CallOption) (*documents.DeleteCollectionResponse, error)
	UpdateCollection(ctx context.Context, in *documents.UpdateCollectionRequest, opts ...grpc.CallOption) (*documents.UpdateCollectionResponse, error)
}

type documentServiceClient struct {
	cc *grpc.ClientConn
}

func NewDocumentServiceClient(cc *grpc.ClientConn) DocumentServiceClient {
	return &documentServiceClient{cc}
}

func (c *documentServiceClient) CreateDoc(ctx context.Context, in *documents.CreateDocRequest, opts ...grpc.CallOption) (*documents.Document, error) {
	out := new(documents.Document)
	err := c.cc.Invoke(ctx, "/saas.DocumentService/CreateDoc", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentServiceClient) GetDoc(ctx context.Context, in *documents.GetDocRequest, opts ...grpc.CallOption) (*documents.GetDocResponse, error) {
	out := new(documents.GetDocResponse)
	err := c.cc.Invoke(ctx, "/saas.DocumentService/GetDoc", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentServiceClient) GetAllDoc(ctx context.Context, in *documents.GetAllDocRequest, opts ...grpc.CallOption) (*documents.GetAllDocResponse, error) {
	out := new(documents.GetAllDocResponse)
	err := c.cc.Invoke(ctx, "/saas.DocumentService/GetAllDoc", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentServiceClient) DeleteDoc(ctx context.Context, in *documents.DeleteDocRequest, opts ...grpc.CallOption) (*documents.DeleteDocResponse, error) {
	out := new(documents.DeleteDocResponse)
	err := c.cc.Invoke(ctx, "/saas.DocumentService/DeleteDoc", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentServiceClient) UpdateDoc(ctx context.Context, in *documents.UpdateDocRequest, opts ...grpc.CallOption) (*documents.UpdateDocResponse, error) {
	out := new(documents.UpdateDocResponse)
	err := c.cc.Invoke(ctx, "/saas.DocumentService/UpdateDoc", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentServiceClient) CreateCollection(ctx context.Context, in *documents.CreateCollectionRequest, opts ...grpc.CallOption) (*documents.CreateCollectionResponse, error) {
	out := new(documents.CreateCollectionResponse)
	err := c.cc.Invoke(ctx, "/saas.DocumentService/CreateCollection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentServiceClient) GetCollection(ctx context.Context, in *documents.GetCollectionRequest, opts ...grpc.CallOption) (*documents.GetCollectionResponse, error) {
	out := new(documents.GetCollectionResponse)
	err := c.cc.Invoke(ctx, "/saas.DocumentService/GetCollection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentServiceClient) GetAllCollection(ctx context.Context, in *documents.GetAllCollectionRequest, opts ...grpc.CallOption) (*documents.GetAllCollectionResponse, error) {
	out := new(documents.GetAllCollectionResponse)
	err := c.cc.Invoke(ctx, "/saas.DocumentService/GetAllCollection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentServiceClient) DeleteCollection(ctx context.Context, in *documents.DeleteCollectionRequest, opts ...grpc.CallOption) (*documents.DeleteCollectionResponse, error) {
	out := new(documents.DeleteCollectionResponse)
	err := c.cc.Invoke(ctx, "/saas.DocumentService/DeleteCollection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentServiceClient) UpdateCollection(ctx context.Context, in *documents.UpdateCollectionRequest, opts ...grpc.CallOption) (*documents.UpdateCollectionResponse, error) {
	out := new(documents.UpdateCollectionResponse)
	err := c.cc.Invoke(ctx, "/saas.DocumentService/UpdateCollection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DocumentServiceServer is the server API for DocumentService service.
type DocumentServiceServer interface {
	CreateDoc(context.Context, *documents.CreateDocRequest) (*documents.Document, error)
	GetDoc(context.Context, *documents.GetDocRequest) (*documents.GetDocResponse, error)
	GetAllDoc(context.Context, *documents.GetAllDocRequest) (*documents.GetAllDocResponse, error)
	DeleteDoc(context.Context, *documents.DeleteDocRequest) (*documents.DeleteDocResponse, error)
	UpdateDoc(context.Context, *documents.UpdateDocRequest) (*documents.UpdateDocResponse, error)
	CreateCollection(context.Context, *documents.CreateCollectionRequest) (*documents.CreateCollectionResponse, error)
	GetCollection(context.Context, *documents.GetCollectionRequest) (*documents.GetCollectionResponse, error)
	GetAllCollection(context.Context, *documents.GetAllCollectionRequest) (*documents.GetAllCollectionResponse, error)
	DeleteCollection(context.Context, *documents.DeleteCollectionRequest) (*documents.DeleteCollectionResponse, error)
	UpdateCollection(context.Context, *documents.UpdateCollectionRequest) (*documents.UpdateCollectionResponse, error)
}

func RegisterDocumentServiceServer(s *grpc.Server, srv DocumentServiceServer) {
	s.RegisterService(&_DocumentService_serviceDesc, srv)
}

func _DocumentService_CreateDoc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(documents.CreateDocRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentServiceServer).CreateDoc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/saas.DocumentService/CreateDoc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentServiceServer).CreateDoc(ctx, req.(*documents.CreateDocRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocumentService_GetDoc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(documents.GetDocRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentServiceServer).GetDoc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/saas.DocumentService/GetDoc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentServiceServer).GetDoc(ctx, req.(*documents.GetDocRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocumentService_GetAllDoc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(documents.GetAllDocRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentServiceServer).GetAllDoc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/saas.DocumentService/GetAllDoc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentServiceServer).GetAllDoc(ctx, req.(*documents.GetAllDocRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocumentService_DeleteDoc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(documents.DeleteDocRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentServiceServer).DeleteDoc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/saas.DocumentService/DeleteDoc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentServiceServer).DeleteDoc(ctx, req.(*documents.DeleteDocRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocumentService_UpdateDoc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(documents.UpdateDocRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentServiceServer).UpdateDoc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/saas.DocumentService/UpdateDoc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentServiceServer).UpdateDoc(ctx, req.(*documents.UpdateDocRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocumentService_CreateCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(documents.CreateCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentServiceServer).CreateCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/saas.DocumentService/CreateCollection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentServiceServer).CreateCollection(ctx, req.(*documents.CreateCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocumentService_GetCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(documents.GetCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentServiceServer).GetCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/saas.DocumentService/GetCollection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentServiceServer).GetCollection(ctx, req.(*documents.GetCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocumentService_GetAllCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(documents.GetAllCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentServiceServer).GetAllCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/saas.DocumentService/GetAllCollection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentServiceServer).GetAllCollection(ctx, req.(*documents.GetAllCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocumentService_DeleteCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(documents.DeleteCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentServiceServer).DeleteCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/saas.DocumentService/DeleteCollection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentServiceServer).DeleteCollection(ctx, req.(*documents.DeleteCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocumentService_UpdateCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(documents.UpdateCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentServiceServer).UpdateCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/saas.DocumentService/UpdateCollection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentServiceServer).UpdateCollection(ctx, req.(*documents.UpdateCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _DocumentService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "saas.DocumentService",
	HandlerType: (*DocumentServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateDoc",
			Handler:    _DocumentService_CreateDoc_Handler,
		},
		{
			MethodName: "GetDoc",
			Handler:    _DocumentService_GetDoc_Handler,
		},
		{
			MethodName: "GetAllDoc",
			Handler:    _DocumentService_GetAllDoc_Handler,
		},
		{
			MethodName: "DeleteDoc",
			Handler:    _DocumentService_DeleteDoc_Handler,
		},
		{
			MethodName: "UpdateDoc",
			Handler:    _DocumentService_UpdateDoc_Handler,
		},
		{
			MethodName: "CreateCollection",
			Handler:    _DocumentService_CreateCollection_Handler,
		},
		{
			MethodName: "GetCollection",
			Handler:    _DocumentService_GetCollection_Handler,
		},
		{
			MethodName: "GetAllCollection",
			Handler:    _DocumentService_GetAllCollection_Handler,
		},
		{
			MethodName: "DeleteCollection",
			Handler:    _DocumentService_DeleteCollection_Handler,
		},
		{
			MethodName: "UpdateCollection",
			Handler:    _DocumentService_UpdateCollection_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "saas/saas.proto",
}

// RenderServiceClient is the client API for RenderService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RenderServiceClient interface {
	Render(ctx context.Context, in *strings.RenderRequest, opts ...grpc.CallOption) (*strings.RenderResponse, error)
}

type renderServiceClient struct {
	cc *grpc.ClientConn
}

func NewRenderServiceClient(cc *grpc.ClientConn) RenderServiceClient {
	return &renderServiceClient{cc}
}

func (c *renderServiceClient) Render(ctx context.Context, in *strings.RenderRequest, opts ...grpc.CallOption) (*strings.RenderResponse, error) {
	out := new(strings.RenderResponse)
	err := c.cc.Invoke(ctx, "/saas.RenderService/Render", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RenderServiceServer is the server API for RenderService service.
type RenderServiceServer interface {
	Render(context.Context, *strings.RenderRequest) (*strings.RenderResponse, error)
}

func RegisterRenderServiceServer(s *grpc.Server, srv RenderServiceServer) {
	s.RegisterService(&_RenderService_serviceDesc, srv)
}

func _RenderService_Render_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(strings.RenderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RenderServiceServer).Render(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/saas.RenderService/Render",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RenderServiceServer).Render(ctx, req.(*strings.RenderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _RenderService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "saas.RenderService",
	HandlerType: (*RenderServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Render",
			Handler:    _RenderService_Render_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "saas/saas.proto",
}

// ByteStreamClient is the client API for ByteStream service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ByteStreamClient interface {
	Read(ctx context.Context, in *streaming.ReadRequest, opts ...grpc.CallOption) (ByteStream_ReadClient, error)
	Write(ctx context.Context, opts ...grpc.CallOption) (ByteStream_WriteClient, error)
}

type byteStreamClient struct {
	cc *grpc.ClientConn
}

func NewByteStreamClient(cc *grpc.ClientConn) ByteStreamClient {
	return &byteStreamClient{cc}
}

func (c *byteStreamClient) Read(ctx context.Context, in *streaming.ReadRequest, opts ...grpc.CallOption) (ByteStream_ReadClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ByteStream_serviceDesc.Streams[0], "/saas.ByteStream/Read", opts...)
	if err != nil {
		return nil, err
	}
	x := &byteStreamReadClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ByteStream_ReadClient interface {
	Recv() (*streaming.ReadResponse, error)
	grpc.ClientStream
}

type byteStreamReadClient struct {
	grpc.ClientStream
}

func (x *byteStreamReadClient) Recv() (*streaming.ReadResponse, error) {
	m := new(streaming.ReadResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *byteStreamClient) Write(ctx context.Context, opts ...grpc.CallOption) (ByteStream_WriteClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ByteStream_serviceDesc.Streams[1], "/saas.ByteStream/Write", opts...)
	if err != nil {
		return nil, err
	}
	x := &byteStreamWriteClient{stream}
	return x, nil
}

type ByteStream_WriteClient interface {
	Send(*streaming.WriteRequest) error
	CloseAndRecv() (*streaming.WriteResponse, error)
	grpc.ClientStream
}

type byteStreamWriteClient struct {
	grpc.ClientStream
}

func (x *byteStreamWriteClient) Send(m *streaming.WriteRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *byteStreamWriteClient) CloseAndRecv() (*streaming.WriteResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(streaming.WriteResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ByteStreamServer is the server API for ByteStream service.
type ByteStreamServer interface {
	Read(*streaming.ReadRequest, ByteStream_ReadServer) error
	Write(ByteStream_WriteServer) error
}

func RegisterByteStreamServer(s *grpc.Server, srv ByteStreamServer) {
	s.RegisterService(&_ByteStream_serviceDesc, srv)
}

func _ByteStream_Read_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(streaming.ReadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ByteStreamServer).Read(m, &byteStreamReadServer{stream})
}

type ByteStream_ReadServer interface {
	Send(*streaming.ReadResponse) error
	grpc.ServerStream
}

type byteStreamReadServer struct {
	grpc.ServerStream
}

func (x *byteStreamReadServer) Send(m *streaming.ReadResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _ByteStream_Write_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ByteStreamServer).Write(&byteStreamWriteServer{stream})
}

type ByteStream_WriteServer interface {
	SendAndClose(*streaming.WriteResponse) error
	Recv() (*streaming.WriteRequest, error)
	grpc.ServerStream
}

type byteStreamWriteServer struct {
	grpc.ServerStream
}

func (x *byteStreamWriteServer) SendAndClose(m *streaming.WriteResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *byteStreamWriteServer) Recv() (*streaming.WriteRequest, error) {
	m := new(streaming.WriteRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _ByteStream_serviceDesc = grpc.ServiceDesc{
	ServiceName: "saas.ByteStream",
	HandlerType: (*ByteStreamServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Read",
			Handler:       _ByteStream_Read_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Write",
			Handler:       _ByteStream_Write_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "saas/saas.proto",
}

// ScannerServiceClient is the client API for ScannerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ScannerServiceClient interface {
	Replace(ctx context.Context, in *strings.ReplaceRequest, opts ...grpc.CallOption) (*strings.ReplaceResponse, error)
	Extract(ctx context.Context, in *strings.ExtractRequest, opts ...grpc.CallOption) (*strings.ExtractResponse, error)
}

type scannerServiceClient struct {
	cc *grpc.ClientConn
}

func NewScannerServiceClient(cc *grpc.ClientConn) ScannerServiceClient {
	return &scannerServiceClient{cc}
}

func (c *scannerServiceClient) Replace(ctx context.Context, in *strings.ReplaceRequest, opts ...grpc.CallOption) (*strings.ReplaceResponse, error) {
	out := new(strings.ReplaceResponse)
	err := c.cc.Invoke(ctx, "/saas.ScannerService/Replace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scannerServiceClient) Extract(ctx context.Context, in *strings.ExtractRequest, opts ...grpc.CallOption) (*strings.ExtractResponse, error) {
	out := new(strings.ExtractResponse)
	err := c.cc.Invoke(ctx, "/saas.ScannerService/Extract", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ScannerServiceServer is the server API for ScannerService service.
type ScannerServiceServer interface {
	Replace(context.Context, *strings.ReplaceRequest) (*strings.ReplaceResponse, error)
	Extract(context.Context, *strings.ExtractRequest) (*strings.ExtractResponse, error)
}

func RegisterScannerServiceServer(s *grpc.Server, srv ScannerServiceServer) {
	s.RegisterService(&_ScannerService_serviceDesc, srv)
}

func _ScannerService_Replace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(strings.ReplaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScannerServiceServer).Replace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/saas.ScannerService/Replace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScannerServiceServer).Replace(ctx, req.(*strings.ReplaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScannerService_Extract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(strings.ExtractRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScannerServiceServer).Extract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/saas.ScannerService/Extract",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScannerServiceServer).Extract(ctx, req.(*strings.ExtractRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ScannerService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "saas.ScannerService",
	HandlerType: (*ScannerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Replace",
			Handler:    _ScannerService_Replace_Handler,
		},
		{
			MethodName: "Extract",
			Handler:    _ScannerService_Extract_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "saas/saas.proto",
}
